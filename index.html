<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover">
<title>Ëã±Ë™ûÂ§úÂ∏ÇÔΩúEnglish Night Market</title>
<style>
  html,body { height:100%; margin:0; background:#0b0f1a; }
  canvas { display:block; width:100vw; height:100vh; outline:none; }

  /* Top control bar */
  #topControls {
    position:fixed; left:12px; top:12px; z-index:10;
    display:flex; gap:10px; font:14px/1.2 system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto;
    color:#fff;
  }
  .pill {
    background:#0e1626; border:1px solid rgba(255,255,255,.15); border-radius:12px;
    padding:8px 10px; display:flex; gap:8px; align-items:center;
  }
  .pill button, .pill select {
    background:#172034; color:#fff; border:1px solid rgba(255,255,255,.15);
    border-radius:8px; padding:6px 10px; cursor:pointer;
  }
  .pill button:hover { filter:brightness(1.1); }
  .pill select { outline:none; }
  #authStatus { opacity:.8; }
</style>
</head>
<body>

<!-- === Music / SFX / Difficulty / Auth =================================== -->
<div id="topControls">
  <div class="pill">
    <button id="musicBtn">üîà Music</button>
    <button id="sfxBtn">üîï SFX</button>
  </div>
  <div class="pill">
    <label>Mode&nbsp;
      <select id="modeSel">
        <option value="easy">Easy</option>
        <option value="normal" selected>Normal</option>
        <option value="hard">Hard</option>
      </select>
    </label>
    <span id="timerHint" style="opacity:.8"></span>
  </div>
  <div class="pill">
    <span id="authStatus">Êú™ÁôªÂÖ•</span>
    <button id="loginBtn">ÁôªÂÖ•</button>
    <button id="logoutBtn" style="display:none">ÁôªÂá∫</button>
  </div>
</div>

<!-- Audio (place mp3 files in /audio/) -->
<audio id="bgm" src="./audio/bgm.mp3" loop preload="auto"></audio>
<audio id="sfxCorrect" src="./audio/correct.mp3" preload="auto"></audio>
<audio id="sfxWrong"   src="./audio/wrong.mp3"   preload="auto"></audio>
<audio id="sfxTick"    src="./audio/tick.mp3"    preload="auto"></audio>

<canvas id="app" tabindex="0"></canvas>

<!-- (Optional) Firebase for login/cloud save. Leave as-is to stay offline. -->
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>

<script>
(() => {
  // ====== Config & Utilities ==================================================
  const CANVAS = document.getElementById('app');
  const CTX = CANVAS.getContext('2d');
  const DPR = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
  function resize() {
    CANVAS.width  = Math.floor(window.innerWidth * DPR);
    CANVAS.height = Math.floor(window.innerHeight * DPR);
    CANVAS.style.width  = window.innerWidth + 'px';
    CANVAS.style.height = window.innerHeight + 'px';
  }
  window.addEventListener('resize', resize);

  const TODAY = () => new Date().toISOString().slice(0,10); // YYYY-MM-DD
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
  const lerp = (a,b,t)=>a+(b-a)*t;

  // Colors
  const COL = {
    bgTop:'#0b0f1a', bgBot:'#1a2236', jade:'#1cc2a0', red:'#ff3b30',
    lantern:'#ff934d', gold:'#ffcf59', ink:'#101422', ink2:'#172036',
    card:'#11203a', line:'rgba(255,255,255,0.15)', white:'#ffffff',
    faint:'rgba(255,255,255,0.6)', dim:'rgba(255,255,255,0.35)',
    green:'#23d18b', blue:'#38a1ff', pink:'#ff5fa2', purple:'#8a7dff',
  };

  // ====== Modes & Timers ======================================================
  const MODES = {
    easy:   { quizTime: 25, snakeTick: 140, label:'‚è±25s / üêçÊÖ¢' },
    normal: { quizTime: 15, snakeTick: 120, label:'‚è±15s / üêç‰∏≠' },
    hard:   { quizTime: 7,  snakeTick: 95,  label:'‚è±7s / üêçÂø´' }
  };
  let currentMode = localStorage.getItem('nm_mode') || 'normal';
  document.getElementById('modeSel').value = currentMode;
  document.getElementById('timerHint').textContent = MODES[currentMode].label;

  function setMode(m){
    currentMode = (m in MODES) ? m : 'normal';
    localStorage.setItem('nm_mode', currentMode);
    document.getElementById('modeSel').value = currentMode;
    document.getElementById('timerHint').textContent = MODES[currentMode].label;
    if (game) game.tickMs = MODES[currentMode].snakeTick;
    // switch vocab by mode (fallback to easy)
    loadModeWords(currentMode);
  }
  document.getElementById('modeSel').addEventListener('change', e=> setMode(e.target.value));

  // ====== Audio ===============================================================
  const A = {
    bgm: document.getElementById('bgm'),
    ok:  document.getElementById('sfxCorrect'),
    bad: document.getElementById('sfxWrong'),
    tick:document.getElementById('sfxTick')
  };
  let musicOn = localStorage.getItem('nm_music')==='1';
  let sfxOn    = localStorage.getItem('nm_sfx')==='1';
  function updateMusicUI(){
    const b = document.getElementById('musicBtn');
    b.textContent = musicOn ? 'üîä Music' : 'üîà Music';
  }
  function updateSfxUI(){
    const b = document.getElementById('sfxBtn');
    b.textContent = sfxOn ? 'üîî SFX' : 'üîï SFX';
  }
  function playSfx(which){
    if (!sfxOn) return;
    const el = which==='ok'?A.ok:which==='bad'?A.bad:which==='tick'?A.tick:null;
    if (el){ try{ el.currentTime = 0; el.play(); }catch{} }
  }
  document.getElementById('musicBtn').onclick = async ()=>{
    musicOn = !musicOn; localStorage.setItem('nm_music', musicOn?'1':'0');
    updateMusicUI();
    if (musicOn) { try{ await A.bgm.play(); }catch{} } else { A.bgm.pause(); }
  };
  document.getElementById('sfxBtn').onclick = ()=>{
    sfxOn = !sfxOn; localStorage.setItem('nm_sfx', sfxOn?'1':'0'); updateSfxUI();
  };
  updateMusicUI(); updateSfxUI();

  // ====== (Optional) Firebase Auth + Cloud Save ==============================
  const FIREBASE_CONFIG = {
    // üîß FILL THESE OR LEAVE EMPTY TO STAY OFFLINE:
    // apiKey: "YOUR_API_KEY",
    // authDomain: "YOUR_PROJECT.firebaseapp.com",
    // projectId: "YOUR_PROJECT_ID",
    // appId: "YOUR_APP_ID"
  };
  let fb = { app:null, auth:null, db:null, user:null, enabled:false };

  function initFirebase(){
    try{
      if (!FIREBASE_CONFIG || !FIREBASE_CONFIG.apiKey) return; // offline
      fb.app  = firebase.initializeApp(FIREBASE_CONFIG);
      fb.auth = firebase.auth();
      fb.db   = firebase.firestore();
      fb.enabled = true;
      fb.auth.onAuthStateChanged(async(u)=>{
        fb.user = u || null;
        updateAuthUI();
        if (fb.user){ await loadProfileFromCloudMerge(); }
      });
    }catch(e){ fb.enabled=false; }
  }
  async function signIn(){
    if (!fb.enabled){ alert('Ê≠§Á´ôÁõÆÂâç‰ª•Êú¨Ê©üÊ®°ÂºèÈÅã‰ΩúÔºàÊú™Ë®≠ÂÆö FirebaseÔºâ'); return; }
    try{
      const provider = new firebase.auth.GoogleAuthProvider();
      await fb.auth.signInWithPopup(provider);
    }catch(e){ console.warn(e); }
  }
  async function signOut(){
    if (!fb.enabled) return;
    try{ await fb.auth.signOut(); }catch(e){}
  }
  function updateAuthUI(){
    const s = document.getElementById('authStatus');
    const inBtn = document.getElementById('loginBtn');
    const outBtn= document.getElementById('logoutBtn');
    if (fb.user){
      s.textContent = `Â∑≤ÁôªÂÖ•Ôºö${fb.user.displayName || fb.user.email}`;
      inBtn.style.display='none'; outBtn.style.display='';
      if (musicOn) A.bgm.play().catch(()=>{});
    }else{
      s.textContent = 'Êú™ÁôªÂÖ•';
      inBtn.style.display=''; outBtn.style.display='none';
    }
  }
  document.getElementById('loginBtn').onclick = signIn;
  document.getElementById('logoutBtn').onclick = signOut;

  // ====== Local/Cloud profile ================================================
  const STORE_KEY = 'nightmarket_english_profile_v1';
  function newProfile(){
    return { createdAt:TODAY(), updatedAt:Date.now(), daily:{}, learnedWords:[], xp:0, streak:0, lastDate:'', highScore:0 };
  }
  function loadProfileLocal(){
    try { return JSON.parse(localStorage.getItem(STORE_KEY) || 'null') || newProfile(); }
    catch { return newProfile(); }
  }
  async function loadProfileFromCloudMerge(){
    // Merge cloud & local; prefer the most recently updated
    const local = loadProfileLocal();
    try{
      const ref = fb.db.collection('nightmarket_profiles').doc(fb.user.uid);
      const snap = await ref.get();
      let cloud = snap.exists ? snap.data() : null;
      let chosen = local;
      if (cloud){
        chosen = (cloud.updatedAt||0) > (local.updatedAt||0) ? cloud : local;
      }
      profile = ensureStreak(chosen); saveProfile(); // save back to both
    }catch(e){ /* stay local */ }
    draw();
  }
  function ensureStreak(p){
    const today = TODAY();
    if (p.lastDate !== today) {
      const prev = p.lastDate;
      const yday = new Date(); yday.setDate(yday.getDate()-1);
      const ystr = yday.toISOString().slice(0,10);
      p.streak = (prev === ystr) ? (p.streak||0)+1 : 1;
      p.lastDate = today;
      if (!p.daily[today]) p.daily[today] = { xp:0, words:0, games:0 };
    }
    return p;
  }
  async function saveProfile(){
    profile.updatedAt = Date.now();
    localStorage.setItem(STORE_KEY, JSON.stringify(profile));
    if (fb.enabled && fb.user){
      try{
        await fb.db.collection('nightmarket_profiles').doc(fb.user.uid).set(profile, { merge:true });
      }catch(e){ /* ignore */ }
    }
  }
  let profile = ensureStreak(loadProfileLocal());

  // ====== Vocabulary (by mode) ===============================================
  let TOPICS = {};          // { "Groceries": [ {en, zh}, ... ], ... }
  let TOPIC_NAMES = [];
  let currentTopic = 'Groceries';
  let WORDS = [];
  let wordsReady = false;
  let wordIndex = 0;

  function setTopic(name){
    currentTopic = name;
    WORDS = (TOPICS[name] || []).slice();
    wordIndex = 0;
    flash = { deck: shuffle([...WORDS]), showBack:false, current:null, lastFlip:0 };
    quiz  = { q:null, options:[], correct:0, total:0, feedback:'', deadline:0, lastSecond:null };
    if (screen===SCREENS.SNAKE) startGame();
    saveProfile();
  }

  async function loadModeWords(mode){
    const map = {
      easy:   './words.json',
      normal: './words_medium.json',
      hard:   './words_hard.json'
    };
    const url = map[mode] || map.easy;
    try{
      const res = await fetch(url+'?v='+Date.now(), {cache:'no-store'});
      if (!res.ok) throw 0;
      const data = await res.json();
      TOPICS = data;
      TOPIC_NAMES = Object.keys(TOPICS);
      if (!TOPIC_NAMES.length) throw 1;
      if (!TOPIC_NAMES.includes(currentTopic)) currentTopic = TOPIC_NAMES[0];
      setTopic(currentTopic);
      wordsReady = true;
      draw();
    }catch{
      if (url.endsWith('words.json')) { return; }
      // fallback to easy
      currentMode = 'easy'; document.getElementById('modeSel').value = 'easy';
      document.getElementById('timerHint').textContent = MODES.easy.label;
      await loadModeWords('easy');
    }
  }

  function nextWord() {
    if (!WORDS.length) return { en: 'loading‚Ä¶', zh: 'ËºâÂÖ•‰∏≠‚Ä¶' };
    const w = WORDS[wordIndex % WORDS.length]; wordIndex++;
    return w;
  }

  // ====== Speech (voice-over) ================================================
  let preferredVoice = null;
  function pickVoice(){
    try{
      const voices = speechSynthesis.getVoices() || [];
      // some nicer voices on Chrome/Android/iOS
      const prefer = [
        /Google US English/i, /Samantha/i, /Victoria/i, /Daniel/i, /Karen/i, /Serena/i, /English \(US\)/i
      ];
      for (const rx of prefer){
        const v = voices.find(v=>rx.test(v.name)||rx.test(v.lang));
        if (v){ preferredVoice = v; return; }
      }
      preferredVoice = voices[0] || null;
    }catch{}
  }
  if ('speechSynthesis' in window){
    window.speechSynthesis.onvoiceschanged = pickVoice;
    pickVoice();
  }
  function speakWord(enWord) {
    try {
      const u = new SpeechSynthesisUtterance(enWord);
      u.lang = 'en-US';
      // slightly vary to feel less robotic
      u.rate = 0.92 + Math.random()*0.12; // 0.92‚Äì1.04
      u.pitch = 0.95 + Math.random()*0.13; // 0.95‚Äì1.08
      if (preferredVoice) u.voice = preferredVoice;
      window.speechSynthesis.cancel();
      window.speechSynthesis.speak(u);
    } catch(e) {}
  }

  // ====== Scene management ====================================================
  const SCREENS = { MENU:'menu', DASH:'dash', FLASH:'flash', QUIZ:'quiz', SNAKE:'snake' };
  let screen = SCREENS.MENU;
  let hoverId = null;

  // GLOBAL buttons map
  const buttons = {};

  // ====== UI primitives on Canvas ============================================
  function drawBg() {
    const {width:w,height:h} = CANVAS;
    const g = CTX.createLinearGradient(0,0,0,h);
    g.addColorStop(0, COL.bgTop);
    g.addColorStop(1, COL.bgBot);
    CTX.fillStyle = g; CTX.fillRect(0,0,w,h);

    // Lantern strings
    const rows = 4, cols = 10;
    for (let r=0;r<rows;r++){
      const y = (h*0.12) + r*(h*0.12);
      CTX.strokeStyle = COL.line; CTX.lineWidth = 2*DPR;
      CTX.beginPath(); CTX.moveTo(w*0.05,y);
      CTX.quadraticCurveTo(w*0.5,y + (r%2?20:-20)*DPR, w*0.95, y);
      CTX.stroke();
      for (let c=0;c<cols;c++){
        const t = c/(cols-1);
        const x = lerp(w*0.05, w*0.95, t);
        drawLantern(x,y + (r%2?12:-12)*DPR, (r%2?1:0));
      }
    }
  }
  function drawLantern(x,y,alt=0){
    CTX.save();
    CTX.translate(x,y);
    CTX.fillStyle = alt?COL.gold:COL.lantern;
    roundedRect(-16*DPR,-12*DPR,32*DPR,24*DPR,8*DPR); CTX.fill();
    CTX.fillStyle = 'rgba(0,0,0,0.2)';
    roundedRect(-16*DPR,-12*DPR,32*DPR,24*DPR,8*DPR);
    CTX.strokeStyle='rgba(255,255,255,0.15)'; CTX.stroke();
    CTX.fillStyle = COL.red; CTX.fillRect(-4*DPR,12*DPR,8*DPR,6*DPR);
    CTX.restore();
  }
  function roundedRect(x,y,w,h,r){
    CTX.beginPath();
    CTX.moveTo(x+r,y);
    CTX.arcTo(x+w,y,x+w,y+h,r);
    CTX.arcTo(x+w,y+h,x,y+h,r);
    CTX.arcTo(x,y+h,x,y,r);
    CTX.arcTo(x,y,x+w,y,r);
    CTX.closePath();
  }
  function drawTitle(){
    const {width:w} = CANVAS;
    CTX.font = `${32*DPR}px sans-serif`;
    CTX.fillStyle = COL.white;
    CTX.textAlign = 'center';
    CTX.fillText('Ëã±Ë™ûÂ§úÂ∏Ç ¬∑ English Night Market', w/2, 60*DPR);
    CTX.font = `${16*DPR}px sans-serif`;
    CTX.fillStyle = COL.faint;
    CTX.fillText('Â≠∏Ëã±Êñá ¬∑ Áé©ÈÅäÊà≤ ¬∑ ÊØèÊó•ÈÄ≤Ê≠•', w/2, 90*DPR);
  }
  function btnRect(cx, cy, w, h){ return {x:cx-w/2, y:cy-h/2, w, h}; }
  function drawButton(id, rect, label, sublabel=null) {
    const isHover = hoverId===id;
    CTX.save();
    CTX.translate(rect.x, rect.y);
    const r = 16*DPR;
    CTX.globalAlpha = isHover?1:0.95;
    CTX.fillStyle = isHover?COL.jade:COL.card;
    roundedRect(0,0,rect.w,rect.h,r); CTX.fill();
    CTX.lineWidth = 2*DPR; CTX.strokeStyle = COL.line; CTX.stroke();
    CTX.fillStyle = isHover?COL.ink:COL.white;
    CTX.textAlign = 'center';
    CTX.font = `${18*DPR}px sans-serif`;
    CTX.fillText(label, rect.w/2, rect.h/2 - (sublabel?6*DPR:0));
    if (sublabel){
      CTX.font = `${12*DPR}px sans-serif`;
      CTX.fillStyle = isHover?COL.ink:'rgba(255,255,255,0.75)';
      CTX.fillText(sublabel, rect.w/2, rect.h/2 + 14*DPR);
    }
    CTX.restore();
  }
  function drawStatPill(x,y,label,value,color){
    CTX.save();
    CTX.translate(x,y);
    const pad = 10*DPR;
    const text = `${label}: ${value}`;
    CTX.font = `${12*DPR}px sans-serif`;
    const m = CTX.measureText(text);
    const w = m.width + pad*2, h = 24*DPR;
    CTX.fillStyle = 'rgba(0,0,0,0.35)';
    roundedRect(0,0,w,h,12*DPR); CTX.fill();
    CTX.strokeStyle = color; CTX.lineWidth = 2*DPR; CTX.stroke();
    CTX.fillStyle = COL.white;
    CTX.textAlign = 'center';
    CTX.fillText(text, w/2, h/2 + 4*DPR);
    CTX.restore();
  }
  function drawProgressRing(cx, cy, r, pct, label){
    CTX.save();
    CTX.translate(cx,cy);
    CTX.lineWidth = 10*DPR;
    CTX.strokeStyle = 'rgba(255,255,255,0.15)';
    CTX.beginPath(); CTX.arc(0,0,r,0,Math.PI*2); CTX.stroke();
    CTX.strokeStyle = COL.jade;
    CTX.beginPath(); CTX.arc(0,0,r,-Math.PI/2, -Math.PI/2 + pct*2*Math.PI); CTX.stroke();
    CTX.fillStyle = COL.white; CTX.textAlign='center';
    CTX.font = `${16*DPR}px sans-serif`;
    CTX.fillText(label,0,6*DPR);
    CTX.restore();
  }

  // ====== Dashboard top bar + Topic picker ===================================
  function drawTopBar(){
    const w = CANVAS.width, h = CANVAS.height;
    const day = profile.daily[TODAY()] || {xp:0,words:0,games:0};
    drawStatPill(w*0.07, h*0.08, 'Streak ÈÄ£Á∫åÂ§©Êï∏', profile.streak, COL.gold);
    drawStatPill(w*0.25, h*0.08, 'XP ‰ªäÊó•Á∂ìÈ©ó', day.xp||0, COL.green);
    drawStatPill(w*0.41, h*0.08, 'Words ÂñÆÂ≠ó', day.words||0, COL.blue);
    drawStatPill(w*0.57, h*0.08, 'High Score ÈÅäÊà≤È´òÂàÜ', profile.highScore||0, COL.pink);

    if (TOPIC_NAMES.length){
      const y = h*0.08;
      const label = `‰∏ªÈ°å TopicÔºö${currentTopic}`;
      CTX.font = `${12*DPR}px sans-serif`;
      const m = CTX.measureText(label);
      const pad = 12*DPR, pillW = m.width + pad*2, pillH = 24*DPR;
      const xCenter = w*0.84;
      const rx = xCenter - pillW/2, ry = y - pillH/2;
      CTX.fillStyle = 'rgba(0,0,0,0.35)';
      roundedRect(rx, ry, pillW, pillH, 12*DPR); CTX.fill();
      CTX.strokeStyle = COL.jade; CTX.lineWidth = 2*DPR; CTX.stroke();
      CTX.fillStyle = COL.white; CTX.textAlign='center';
      CTX.fillText(label, xCenter, y + 4*DPR);

      const aw = 22*DPR, ah = pillH;
      const left  = {x: rx - aw - 6*DPR, y: ry, w: aw, h: ah};
      const right = {x: rx + pillW + 6*DPR, y: ry, w: aw, h: ah};
      buttons['topicPrev'] = left; buttons['topicNext'] = right;
      drawMiniArrow(left,'left'); drawMiniArrow(right,'right');
    }
  }
  function drawMiniArrow(rect, dir){
    CTX.save();
    CTX.translate(rect.x, rect.y);
    CTX.fillStyle = 'rgba(0,0,0,0.35)';
    roundedRect(0,0,rect.w,rect.h,8*DPR); CTX.fill();
    CTX.strokeStyle = COL.line; CTX.lineWidth = 2*DPR; CTX.stroke();
    CTX.fillStyle = COL.white;
    CTX.beginPath();
    const cx = rect.w/2, cy = rect.h/2, d = 6*DPR;
    if (dir==='left'){ CTX.moveTo(cx+d,cy-d); CTX.lineTo(cx-d,cy); CTX.lineTo(cx+d,cy+d); }
    else { CTX.moveTo(cx-d,cy-d); CTX.lineTo(cx+d,cy); CTX.lineTo(cx-d,cy+d); }
    CTX.closePath(); CTX.fill();
    CTX.restore();
  }

  // ====== MENU Screen ========================================================
  function drawMenu(){
    drawBg(); drawTitle(); buttonsClear(); drawTopBar();
    const w = CANVAS.width, h = CANVAS.height;
    const B = [
      {id:'toDash',   y: h*0.28, label:'üìä ÈÄ≤Â∫¶ÂÑÄË°®Êùø Dashboard', sub:'ÊØèÊó•ÁõÆÊ®ô ¬∑ ÂñÆÂ≠óÂÆåÊàêÂ∫¶'},
      {id:'toFlash',  y: h*0.40, label:'üÉè ÂñÆÂ≠óÈñÉÂç° Flashcards',    sub:'ÁøªËΩâÂç°Áâá ¬∑ Ë™çÁü•Âä†Âº∑'},
      {id:'toQuiz',   y: h*0.52, label:'üìù Ê∏¨È©ó Quizzes',           sub:'ÈÅ∏ÊìáÈ°å ¬∑ Âç≥ÊôÇÂæóÂàÜ'},
      {id:'toSnake',  y: h*0.64, label:'üõí ÈòøÂ¨§Ë≤∑ËèúÈÅäÊà≤ (Snake)',     sub:'ÊñπÂêëÈçµÊìçÊéß ¬∑ ÊíøÂà∞Â∞±ÁôºÈü≥'},
    ];
    const rectW = Math.min(w*0.7, 740*DPR), rectH = 68*DPR;
    B.forEach((b)=>{
      const rect = btnRect(w/2, b.y, rectW, rectH);
      buttons[b.id] = rect;
      drawButton(b.id, rect, b.label, b.sub);
    });
    const today = profile.daily[TODAY()] || {xp:0};
    const pct = clamp((today.xp||0)/100,0,1);
    drawProgressRing(w*0.85, h*0.25, 48*DPR, pct, `‰ªäÊó•XP ${today.xp||0}/100`);
  }

  // ====== DASH Screen =========================================================
  function drawDash(){
    drawBg(); drawTitle(); buttonsClear(); drawTopBar();
    const w = CANVAS.width, h = CANVAS.height;

    function card(x,y,ww,hh, title, lines) {
      CTX.save();
      CTX.translate(x,y);
      CTX.fillStyle = COL.card;
      roundedRect(0,0,ww,hh,18*DPR); CTX.fill();
      CTX.strokeStyle = COL.line; CTX.lineWidth = 2*DPR; CTX.stroke();
      CTX.fillStyle = COL.white; CTX.textAlign = 'left';
      CTX.font = `${16*DPR}px sans-serif`;
      CTX.fillText(title, 20*DPR, 34*DPR);
      CTX.font = `${13*DPR}px sans-serif`;
      CTX.fillStyle = COL.faint;
      lines.forEach((ln,i)=> CTX.fillText(ln, 20*DPR, 60*DPR + i*20*DPR));
      CTX.restore();
    }

    const today = profile.daily[TODAY()] || {xp:0,words:0,games:0};
    card(w*0.15, h*0.25, w*0.30, h*0.30,
      '‰ªäÊó•‰ªªÂãô',
      [
        `ÂÆåÊàê 30 XPÔºö${today.xp>=30?'‚úÖ ÂÆåÊàê':'‚¨ú ÈÄ≤Ë°å‰∏≠'}`,
        `Â≠∏ 10 Â≠óÔºö${today.words>=10?'‚úÖ ÂÆåÊàê':`‚¨ú ${today.words||0}/10`}`,
        `Áé©ÈòøÂ¨§Ë≤∑Ëèú 1 Â±ÄÔºö${today.games>=1?'‚úÖ ÂÆåÊàê':'‚¨ú Â∞öÊú™'}`
      ]
    );
    card(w*0.55, h*0.25, w*0.30, h*0.30,
      'Á∏ΩË¶Ω',
      [
        `Ë®ªÂÜäÊó•ÊúüÔºö${profile.createdAt}`,
        `Á¥ØÁ©ç XPÔºö${profile.xp}`,
        `Â∑≤Â≠∏ÂñÆÂ≠óÔºö${profile.learnedWords.length}`
      ]
    );

    const rectW = Math.min(w*0.7, 740*DPR), rectH = 60*DPR, y0 = h*0.66;
    [
      {id:'backMenu',    y: y0, label:'‚Üê ËøîÂõûÁõÆÈåÑ Menu'},
      {id:'toFlash',     y: y0+80*DPR, label:'üÉè ÈñãÂßãÈñÉÂç°'},
      {id:'toQuiz',      y: y0+160*DPR,label:'üìù ÈñãÂßãÊ∏¨È©ó'},
      {id:'toSnake',     y: y0+240*DPR,label:'üõí ÈñãÂßãÈòøÂ¨§Ë≤∑Ëèú'}
    ].forEach(b=>{
      const rect = btnRect(w/2, b.y, rectW, rectH);
      buttons[b.id]=rect; drawButton(b.id, rect, b.label);
    });
  }

  // ====== FLASHCARDS ==========================================================
  let flash = { deck: [], showBack:false, current:null, lastFlip:0 };
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } return a; }
  function drawFlash(){
    drawBg(); drawTitle(); buttonsClear(); drawTopBar();
    const w = CANVAS.width, h = CANVAS.height;
    if (!flash.current) {
      flash.deck = shuffle([...WORDS]);
      flash.current = flash.deck[0] || null;
    }

    const cw = Math.min(520*DPR, w*0.8), ch = Math.min(320*DPR, h*0.5);
    const cx = w/2 - cw/2, cy = h*0.3;
    CTX.save();
    CTX.translate(cx, cy);
    CTX.fillStyle = COL.card;
    roundedRect(0,0,cw,ch,24*DPR); CTX.fill();
    CTX.strokeStyle = COL.line; CTX.lineWidth = 2*DPR; CTX.stroke();
    CTX.textAlign='center';
    if (!flash.current){
      CTX.fillStyle = COL.faint; CTX.font = `${20*DPR}px sans-serif`;
      CTX.fillText(wordsReady?'Ê≤íÊúâÂñÆÂ≠ó':'ËºâÂÖ•ÂñÆÂ≠ó‰∏≠‚Ä¶ Loading words‚Ä¶', cw/2, ch/2);
    } else if (!flash.showBack){
      CTX.fillStyle = COL.white; CTX.font = `${32*DPR}px sans-serif`;
      CTX.fillText(flash.current.en, cw/2, ch/2);
      CTX.fillStyle = COL.dim; CTX.font = `${14*DPR}px sans-serif`;
      CTX.fillText('ÈªûÊìäÂç°ÁâáÁøªÈù¢ Flip card', cw/2, ch-20*DPR);
    } else {
      CTX.fillStyle = COL.jade; CTX.font = `${28*DPR}px sans-serif`;
      CTX.fillText(flash.current.zh, cw/2, ch/2 - 8*DPR);
      CTX.fillStyle = COL.faint; CTX.font = `${16*DPR}px sans-serif`;
      CTX.fillText(flash.current.en, cw/2, ch/2 + 24*DPR);
    }
    CTX.restore();

    const bw = Math.min(660*DPR,w*0.9), bh = 56*DPR, y = cy+ch+80*DPR;
    const b1 = btnRect(w/2, y, bw, bh);
    const b2 = btnRect(w/2, y+80*DPR, bw, bh);
    const b3 = btnRect(w/2, y+160*DPR, bw, bh);
    buttons['flashFlip']=b1; buttons['flashKnow']=b2; buttons['flashPractice']=b3;
    drawButton('flashFlip', b1, 'üîÑ ÁøªÈù¢ / Flip');
    drawButton('flashKnow', b2, '‚úÖ ÊàëÊúÉ‰∫Ü / I knew it');
    drawButton('flashPractice', b3, 'üß† ÈúÄË¶ÅÂ§öÁ∑¥ / Need practice');
    const back = btnRect(w*0.15, h*0.9, 220*DPR, 50*DPR);
    buttons['backMenu']=back; drawButton('backMenu', back, '‚Üê ËøîÂõû Menu');
  }
  function flashFlip(){ flash.showBack = !flash.showBack; }
  function flashAdvance(known){
    if (!flash.deck.length) return;
    grantXP(known ? 5 : 3);
    const cur = flash.current;
    if (known && cur && !profile.learnedWords.includes(cur.en)){
      profile.learnedWords.push(cur.en); incToday('words',1);
    }
    flash.deck.push(flash.deck.shift());
    flash.current = flash.deck[0] || null;
    flash.showBack=false;
    saveProfile();
  }

  // ====== QUIZ (with timer) ===================================================
  let quiz = { q:null, options:[], correct:0, total:0, feedback:'', deadline:0, lastSecond:null };
  function genQuiz(){
    const base = nextWord();
    const wrongs = shuffle([...WORDS].filter(w=>w.en!==base.en)).slice(0,3);
    const options = shuffle([base, ...wrongs]);
    quiz.q = base; quiz.options = options;
    const secs = MODES[currentMode].quizTime;
    quiz.deadline = performance.now() + secs*1000;
    quiz.lastSecond = Math.ceil(secs);
  }
  function timeLeftMs(){ return Math.max(0, quiz.deadline - performance.now()); }

  function drawQuiz(){
    drawBg(); drawTitle(); buttonsClear(); drawTopBar();
    const w = CANVAS.width, h = CANVAS.height;
    if (!quiz.q) genQuiz();
    CTX.textAlign='center';
    const cw = Math.min(520*DPR,w*0.8), ch = 140*DPR;
    const cx = w/2 - cw/2, cy = h*0.25;
    CTX.save();
    CTX.translate(cx, cy);
    CTX.fillStyle = COL.card; roundedRect(0,0,cw,ch,20*DPR); CTX.fill();
    CTX.strokeStyle = COL.line; CTX.lineWidth = 2*DPR; CTX.stroke();
    CTX.fillStyle = COL.white; CTX.font = `${28*DPR}px sans-serif`;
    CTX.fillText(`Ë´ãÈÅ∏Âá∫„Äå${quiz.q.en}„ÄçÁöÑ‰∏≠ÊñáÊÑèÊÄù`, cw/2, ch/2 + 8*DPR);
    CTX.restore();

    // countdown
    const seconds = Math.ceil(timeLeftMs()/1000);
    CTX.fillStyle = seconds<=3 ? COL.red : COL.white;
    CTX.font = `${24*DPR}px sans-serif`;
    CTX.fillText(`‚è± ${seconds}s`, w/2, cy - 24*DPR);

    const bw = Math.min(660*DPR, w*0.9), bh = 56*DPR, y0 = cy+ch+60*DPR;
    quiz.options.forEach((opt,i)=>{
      const r = btnRect(w/2, y0 + i*80*DPR, bw, bh);
      const id = 'quizOpt'+i; buttons[id]=r;
      drawButton(id, r, `${i+1}. ${opt.zh}`);
    });

    CTX.fillStyle = COL.faint; CTX.font = `${14*DPR}px sans-serif`;
    CTX.fillText(`ÂæóÂàÜ ${quiz.correct}/${quiz.total}`, w/2, h*0.85);

    const back = btnRect(w*0.15, h*0.9, 220*DPR, 50*DPR);
    buttons['backMenu']=back; drawButton('backMenu', back, '‚Üê ËøîÂõû Menu');

    if (quiz.feedback){
      CTX.fillStyle = quiz.feedback.startsWith('‚úÖ')?COL.jade:COL.red;
      CTX.font = `${18*DPR}px sans-serif`;
      CTX.fillText(quiz.feedback, w/2, h*0.8);
    }
  }
  function quizChoose(idx){
    quiz.total++;
    const pick = quiz.options[idx];
    if (pick.en === quiz.q.en){
      quiz.correct++; quiz.feedback = '‚úÖ Ê≠£Á¢∫ÔºÅ+10 XP';
      grantXP(10); playSfx('ok');
      if (!profile.learnedWords.includes(pick.en)){
        profile.learnedWords.push(pick.en); incToday('words',1);
      }
    } else {
      quiz.feedback = `‚ùå ÈåØË™§ÔºåÊ≠£Ëß£ÊòØ„Äå${quiz.q.zh}„Äç`;
      grantXP(1); playSfx('bad');
    }
    saveProfile();
    setTimeout(()=>{ quiz.feedback=''; genQuiz(); draw(); }, 700);
  }

  // ====== GRANDMA SNAKE GAME ==================================================
  const GRID = { cols: 26, rows: 18, size: 28 };
  let game = null;

  function startGame(){
    const cell = Math.floor(Math.min(CANVAS.width/(GRID.cols+6), CANVAS.height/(GRID.rows+6)));
    const size = Math.max(18*DPR, cell);
    const cols = Math.floor(CANVAS.width/size)-4;
    const rows = Math.floor(CANVAS.height/size)-6;
    game = {
      size, cols, rows,
      ox: Math.floor((CANVAS.width - cols*size)/2),
      oy: Math.floor((CANVAS.height - rows*size)/2)+20*DPR,
      dir: {x:1,y:0}, nextDir: {x:1,y:0},
      snake: [], grocery: null, tickMs: MODES[currentMode].snakeTick, elapsed: 0,
      lastTick: performance.now(), alive: true, score: 0,
      wordOnPickup: null, started: false, paused: false
    };
    const x0 = Math.floor(cols/3), y0 = Math.floor(rows/2);
    game.snake = [{x:x0,y:y0},{x:x0-1,y:y0},{x:x0-2,y:y0}];
    game.grocery = spawnGrocery();
    incToday('games',0);
  }

  function drawSnake(){
    drawBg(); drawTitle(); buttonsClear(); drawTopBar();
    if (!game) startGame();

    CTX.save();
    CTX.translate(game.ox, game.oy);
    CTX.fillStyle = COL.ink2;
    roundedRect(0,0,game.cols*game.size,game.rows*game.size,16*DPR); CTX.fill();

    CTX.strokeStyle='rgba(255,255,255,0.06)'; CTX.lineWidth=1*DPR;
    CTX.beginPath();
    for (let c=1;c<game.cols;c++){ const x=c*game.size; CTX.moveTo(x,0); CTX.lineTo(x,game.rows*game.size); }
    for (let r=1;r<game.rows;r++){ const y=r*game.size; CTX.moveTo(0,y); CTX.lineTo(game.cols*game.size,y); }
    CTX.stroke();

    if (game.grocery) drawGrocery(game.grocery.x, game.grocery.y);

    for (let i=game.snake.length-1; i>=0; i--){
      const seg = game.snake[i];
      if (i===0) drawGrandma(seg.x, seg.y, game.dir);
      else drawCart(seg.x, seg.y, i);
    }

    CTX.restore();
    const w = CANVAS.width, h = CANVAS.height;
    CTX.fillStyle = COL.white; CTX.textAlign='center';
    CTX.font = `${18*DPR}px sans-serif`;
    CTX.fillText(`ÂàÜÊï∏ Score: ${game.score}`, w/2, game.oy - 16*DPR);

    if (!game.started){
      CTX.fillStyle = COL.faint; CTX.font=`${16*DPR}px sans-serif`;
      CTX.fillText('Êåâ‰∏ãÊñπÂêëÈçµÈñãÂßã ¬∑ Use arrow keys to start', w/2, game.oy + game.rows*game.size + 26*DPR);
    } else if (game.paused){
      CTX.fillStyle = COL.faint; CTX.font=`${16*DPR}px sans-serif`;
      CTX.fillText('Êö´ÂÅú‰∏≠ ¬∑ Press P to resume', w/2, game.oy + game.rows*game.size + 26*DPR);
    } else {
      CTX.fillStyle = COL.dim; CTX.font=`${12*DPR}px sans-serif`;
      CTX.fillText('P = Êö´ÂÅú/ÁπºÁ∫å  R = Èáç‰æÜ  M = Menu', w/2, game.oy + game.rows*game.size + 24*DPR);
    }

    if (game.wordOnPickup){
      CTX.fillStyle = COL.jade;
      CTX.font = `${22*DPR}px sans-serif`;
      CTX.fillText(`+ ${game.wordOnPickup.en} (${game.wordOnPickup.zh})`, w/2, game.oy - 40*DPR);
    }
  }

  function drawGrandma(gx,gy,dir){
    const s = game.size, x = gx*s, y = gy*s;
    CTX.save(); CTX.translate(x,y);
    CTX.fillStyle = '#7c8ba1';
    roundedRect(2,2,s-4,s-4,8*DPR); CTX.fill();

    CTX.save();
    CTX.translate(s/2, s/2);
    CTX.fillStyle = '#ffd9c2';
    CTX.beginPath(); CTX.arc(0,0, s*0.28, 0, Math.PI*2); CTX.fill();
    CTX.fillStyle = '#a7b0bd';
    CTX.beginPath(); CTX.arc(0, -s*0.22, s*0.10, 0, Math.PI*2); CTX.fill();
    CTX.beginPath(); CTX.arc(0, 0, s*0.30, Math.PI*0.7, Math.PI*0.3, true); CTX.strokeStyle='#9aa6b2'; CTX.lineWidth=4*DPR; CTX.stroke();

    CTX.fillStyle = '#3a3a3a';
    const ex = s*0.10, ey = -s*0.02;
    CTX.beginPath(); CTX.arc(-ex, ey, 2.5*DPR, 0, Math.PI*2); CTX.fill();
    CTX.beginPath(); CTX.arc( ex, ey, 2.5*DPR, 0, Math.PI*2); CTX.fill();
    CTX.strokeStyle = '#c05b6e'; CTX.lineWidth = 2.2*DPR;
    CTX.beginPath(); CTX.arc(0, s*0.06, s*0.10, 0, Math.PI); CTX.stroke();

    CTX.restore();

    CTX.strokeStyle = 'rgba(255,255,255,0.6)'; CTX.lineWidth=2*DPR;
    CTX.beginPath();
    const cx = s/2, cy = s*0.82, d = 7*DPR;
    if (dir.x===1){ CTX.moveTo(cx-d,cy); CTX.lineTo(cx+d,cy); CTX.lineTo(cx+d-6,cy-6); }
    if (dir.x===-1){ CTX.moveTo(cx+d,cy); CTX.lineTo(cx-d,cy); CTX.lineTo(cx-d+6,cy-6); }
    if (dir.y===1){ CTX.moveTo(cx,cy-10); CTX.lineTo(cx,cy+8); CTX.lineTo(cx-6,cy+2); }
    if (dir.y===-1){ CTX.moveTo(cx,cy+8); CTX.lineTo(cx,cy-10); CTX.lineTo(cx-6,cy-4); }
    CTX.stroke();
    CTX.restore();
  }
  function drawCart(gx,gy,i){
    const s=game.size, x=gx*s, y=gy*s;
    CTX.save(); CTX.translate(x,y);
    CTX.fillStyle = i%2? '#567' : '#495871';
    roundedRect(4,4,s-8,s-8,6*DPR); CTX.fill();
    CTX.fillStyle = '#222'; CTX.beginPath(); CTX.arc(8, s-6, 3*DPR, 0, 2*Math.PI); CTX.fill();
    CTX.beginPath(); CTX.arc(s-8, s-6, 3*DPR, 0, 2*Math.PI); CTX.fill();
    CTX.restore();
  }
  function drawGrocery(gx,gy){
    const s=game.size, x=gx*s, y=gy*s;
    CTX.save(); CTX.translate(x,y);
    CTX.fillStyle = '#d7a96b';
    roundedRect(4,6,s-8,s-10,6*DPR); CTX.fill();
    CTX.strokeStyle = 'rgba(0,0,0,0.2)'; CTX.stroke();
    CTX.fillStyle = '#5fd16b'; CTX.beginPath(); CTX.arc(s*0.35,8, 4*DPR, 0, 2*Math.PI); CTX.fill();
    CTX.fillStyle = '#ff6b6b'; CTX.beginPath(); CTX.arc(s*0.6,9, 4*DPR, 0, 2*Math.PI); CTX.fill();
    CTX.restore();
  }
  function spawnGrocery(){
    let x,y,ok=false;
    while(!ok){
      x = (Math.random()*game.cols)|0; y = (Math.random()*game.rows)|0;
      ok = !game.snake.some(s=>s.x===x && s.y===y);
    }
    return {x,y};
  }
  function stepGame(now){
    if (!game || !game.alive || game.paused) return;
    const dt = now - game.lastTick;
    if (dt < game.tickMs) return;
    game.lastTick = now;
    game.dir = game.nextDir;

    const head = {...game.snake[0]};
    head.x += game.dir.x; head.y += game.dir.y;
    if (head.x<0||head.y<0||head.x>=game.cols||head.y>=game.rows) return gameOver();
    if (game.snake.some(s=>s.x===head.x && s.y===head.y)) return gameOver();
    game.snake.unshift(head);
    if (head.x===game.grocery.x && head.y===game.grocery.y){
      game.score++;
      profile.highScore = Math.max(profile.highScore||0, game.score);
      if (game.score===1) incToday('games',1);
      grantXP(5);
      const word = nextWord();
      game.wordOnPickup = word;
      if (!profile.learnedWords.includes(word.en)){
        profile.learnedWords.push(word.en); incToday('words',1);
      }
      saveProfile();
      speakWord(word.en);
      game.grocery = spawnGrocery();
      game.tickMs = Math.max(70, game.tickMs-1.5);
    } else {
      game.snake.pop();
    }
  }
  function gameOver(){
    game.alive = false;
    grantXP(3);
    saveProfile();
    const w = CANVAS.width, h = CANVAS.height;
    CTX.fillStyle = 'rgba(0,0,0,0.5)'; CTX.fillRect(0,0,w,h);
    CTX.fillStyle = COL.white; CTX.textAlign='center';
    CTX.font = `${28*DPR}px sans-serif`;
    CTX.fillText('ÈÅäÊà≤ÁµêÊùü ¬∑ Game Over', w/2, h/2 - 30*DPR);
    CTX.font = `${18*DPR}px sans-serif`;
    CTX.fillText(`ÂàÜÊï∏ Score: ${game.score}   ÊúÄÈ´ò High: ${profile.highScore}`, w/2, h/2 + 6*DPR);
    CTX.fillText('Êåâ R ÈáçÊñ∞ÈñãÂßã ¬∑ Press R to restart', w/2, h/2 + 36*DPR);
  }

  // ====== Progress helpers ====================================================
  function incToday(key, by=1){
    const t = TODAY();
    if (!profile.daily[t]) profile.daily[t] = {xp:0, words:0, games:0};
    profile.daily[t][key] = (profile.daily[t][key]||0) + by;
  }
  function grantXP(v){ profile.xp += v; incToday('xp', v); }

  // ====== Input handling ======================================================
  CANVAS.addEventListener('mousemove', (e)=>{
    const rect = CANVAS.getBoundingClientRect();
    const x = (e.clientX - rect.left)*DPR;
    const y = (e.clientY - rect.top)*DPR;
    hoverId = null;
    for (const [id,r] of Object.entries(buttons)){
      if (x>=r.x && x<=r.x+r.w && y>=r.y && y<=r.y+r.h) { hoverId=id; break; }
    }
    draw();
  });
  CANVAS.addEventListener('click', ()=>{
    if (!hoverId) return;
    handleButton(hoverId);
  });

  CANVAS.addEventListener('keydown', (e)=>{
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
    if (screen===SCREENS.SNAKE && game){
      if (!game.started && ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) game.started=true;
      if (e.key==='ArrowUp' && game.dir.y!==1) game.nextDir={x:0,y:-1};
      if (e.key==='ArrowDown' && game.dir.y!==-1) game.nextDir={x:0,y:1};
      if (e.key==='ArrowLeft' && game.dir.x!==1) game.nextDir={x:-1,y:0};
      if (e.key==='ArrowRight' && game.dir.x!==-1) game.nextDir={x:1,y:0};
      if (e.key==='p' || e.key==='P'){ if(game.started){ game.paused=!game.paused; } }
      if (e.key==='r' || e.key==='R'){ startGame(); }
      if (e.key==='m' || e.key==='M'){ screen=SCREENS.MENU; }
    }
    if (e.key==='Escape'){ screen=SCREENS.MENU; }
    draw();
  });

  function cycleTopic(dir){
    if (!TOPIC_NAMES.length) return;
    const i = TOPIC_NAMES.indexOf(currentTopic);
    const ni = (i + (dir==='next'?1:-1) + TOPIC_NAMES.length) % TOPIC_NAMES.length;
    setTopic(TOPIC_NAMES[ni]);
    draw();
  }

  function handleButton(id){
    switch(id){
      case 'toDash': screen=SCREENS.DASH; break;
      case 'toFlash': screen=SCREENS.FLASH; break;
      case 'toQuiz': screen=SCREENS.QUIZ; break;
      case 'toSnake': screen=SCREENS.SNAKE; startGame(); break;
      case 'backMenu': screen=SCREENS.MENU; break;
      case 'topicPrev': cycleTopic('prev'); return;
      case 'topicNext': cycleTopic('next'); return;
      case 'flashFlip': flashFlip(); break;
      case 'flashKnow': flashAdvance(true); break;
      case 'flashPractice': flashAdvance(false); break;
      default:
        if (id.startsWith('quizOpt')) {
          const idx = +id.replace('quizOpt','');
          quizChoose(idx);
        }
    }
    draw();
  }

  // ====== Main draw loop ======================================================
  function draw() {
    switch(screen){
      case SCREENS.MENU:  drawMenu(); break;
      case SCREENS.DASH:  drawDash(); break;
      case SCREENS.FLASH: drawFlash(); break;
      case SCREENS.QUIZ:  drawQuiz(); break;
      case SCREENS.SNAKE: drawSnake(); break;
    }
  }
  function buttonsClear(){ for (const k of Object.keys(buttons)) delete buttons[k]; }

  function tick(now){
    if (screen===SCREENS.SNAKE && game && game.alive && game.started && !game.paused){
      stepGame(now);
      draw();
    }
    // quiz timer tick
    if (screen===SCREENS.QUIZ && quiz.q){
      const secs = Math.ceil(timeLeftMs()/1000);
      if (quiz.lastSecond !== secs){
        quiz.lastSecond = secs;
        if (secs<=3 && secs>0) playSfx('tick');
        draw();
      }
      if (timeLeftMs()<=0){
        quiz.total++;
        quiz.feedback = `‚åõ ÊôÇÈñìÂà∞ÔºÅÊ≠£Ëß£ÊòØ„Äå${quiz.q.zh}„Äç`;
        playSfx('bad');
        setTimeout(()=>{ quiz.feedback=''; genQuiz(); draw(); }, 700);
      }
    }
    requestAnimationFrame(tick);
  }

  // ====== Boot ================================================================
  resize();
  initFirebase();                    // optional; harmless if not configured
  setMode(currentMode);              // loads words for mode + sets speeds
  draw();
  requestAnimationFrame(tick);
  CANVAS.focus();
})();
</script>
</body>
</html>
