<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover">
<title>Ëã±Ë™ûÂ§úÂ∏ÇÔΩúEnglish Night Market</title>
<meta name="color-scheme" content="dark">
<style>
  :root{
    --bg1:#0b0f1a; --bg2:#1a2236; --ink:#101422; --card:#11203a; --line:rgba(255,255,255,.15);
    --white:#fff; --faint:rgba(255,255,255,.7); --dim:rgba(255,255,255,.38);
    --jade:#1cc2a0; --red:#ff3b30; --gold:#ffcf59;
  }
  html,body{ height:100%; margin:0; background:var(--bg1); }
  canvas{ display:block; width:100vw; height:100vh; outline:none; }

  /* Controls */
  #topControls{
    position:fixed; left:12px; top:12px; z-index:20;
    display:flex; gap:10px; flex-wrap:wrap;
    font:14px/1.2 system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto;
    color:#fff; max-width:min(100vw - 24px, 1150px);
  }
  .pill{
    background:#0e1626; border:1px solid var(--line); border-radius:12px;
    padding:8px 10px; display:flex; gap:8px; align-items:center;
    box-shadow:0 4px 16px rgba(0,0,0,.25);
  }
  .pill button, .pill select{
    background:#172034; color:#fff; border:1px solid var(--line);
    border-radius:8px; padding:6px 10px; cursor:pointer;
  }
  .pill button:hover{ filter:brightness(1.1); }
  .pill select{ outline:none; max-width:52vw; }
  #authStatus{ opacity:.9; white-space:nowrap; }

  /* Toast */
  #toast{
    position:fixed; left:50%; top:10px; transform:translateX(-50%);
    background:#333; color:#fff; padding:10px 14px; border-radius:12px;
    font:13px/1 system-ui; box-shadow:0 8px 18px rgba(0,0,0,.25);
    display:none; z-index:9999;
  }

  /* On-pickup banner */
  #pickup{
    position:fixed; left:50%; top:50%; transform:translate(-50%,-50%) scale(.98);
    background:rgba(0,0,0,.72);
    color:#fff; border:2px solid rgba(255,255,255,.25); border-radius:22px;
    padding:18px 22px; z-index:15; display:none; text-align:center;
    box-shadow:0 14px 40px rgba(0,0,0,.45);
    transition:transform .2s ease, opacity .2s ease;
  }
  #pickup.show{ display:block; transform:translate(-50%,-50%) scale(1); }
  #pickup .en{ font:700 34px/1.1 ui-sans-serif,system-ui,Segoe UI,Roboto; letter-spacing:.4px; }
  #pickup .zh{ font:500 22px/1.2 ui-sans-serif,system-ui,Segoe UI,Roboto; color:var(--gold); margin-top:6px; }
  #pickup .hint{ font:12px/1.4 system-ui; color:var(--faint); margin-top:4px; }
</style>
</head>
<body>

<!-- Controls -->
<div id="topControls" role="toolbar" aria-label="ÈÅäÊà≤ÊéßÂà∂Âàó">
  <div class="pill" aria-label="Èü≥ÊïàÊéßÂà∂">
    <button id="musicBtn" type="button" aria-pressed="true">üîä Music</button>
    <button id="sfxBtn"   type="button" aria-pressed="true">üîî SFX</button>
  </div>
  <div class="pill" aria-label="Ê®°Âºè">
    <label>Mode&nbsp;
      <select id="modeSel" title="ÂΩ±ÈüøË®àÊôÇËàáÈÅäÊà≤ÈÄüÂ∫¶Ôºå‰∏çÂΩ±ÈüøÊäΩÂ≠ó">
        <option value="easy">Easy</option>
        <option value="normal" selected>Normal</option>
        <option value="hard">Hard</option>
      </select>
    </label>
    <span id="timerHint" style="opacity:.85"></span>
  </div>
  <div class="pill" aria-label="‰∏ªÈ°å">
    <label>Topic&nbsp;
      <select id="topicSel" aria-live="polite"><option value="">Loading‚Ä¶</option></select>
    </label>
  </div>
  <div class="pill" aria-label="Á≠âÁ¥ö">
    <label>Level&nbsp;
      <select id="levelSel" title="‰æù words.json ÁöÑ level Ê¨Ñ‰ΩçÁØ©ÈÅ∏">
        <option value="all" selected>All</option>
        <option value="easy">easy</option>
        <option value="normal">normal</option>
        <option value="hard">hard</option>
      </select>
    </label>
  </div>
  <div class="pill" id="authPill" aria-label="ÁôªÂÖ•ÁãÄÊÖã">
    <span id="authStatus">Èõ¢Á∑öÊ®°Âºè</span>
    <button id="loginBtn"  type="button">ÁôªÂÖ•</button>
    <button id="logoutBtn" type="button" style="display:none">ÁôªÂá∫</button>
  </div>
</div>

<div id="toast" role="status" aria-live="polite"></div>
<div id="pickup" aria-hidden="true"><div class="en"></div><div class="zh"></div><div class="hint">Ôºã5 XP ¬∑ Â∑≤Âî∏Âá∫ÁôºÈü≥</div></div>

<!-- Audio -->
<audio id="bgm" src="./sb_adriftamonginfinitestars(chosic.com).mp3" loop preload="auto" muted></audio>
<audio id="sfxCorrect" src="./audio/correct.mp3" preload="auto" crossorigin="anonymous"></audio>
<audio id="sfxWrong"   src="./audio/wrong.mp3"   preload="auto" crossorigin="anonymous"></audio>
<audio id="sfxTick"    src="./audio/tick.mp3"    preload="auto" crossorigin="anonymous"></audio>

<script>
  // Ëß£ÈéñÈü≥Ë®äÊí≠ÊîæÔºà‰∏ÄÊ¨°‰∫íÂãïÂæåÔºâ
  function unmuteAndPlayOnce() {
    const bgm = document.getElementById('bgm');
    bgm.muted = false;
    bgm.play().catch(()=>{});
    window.removeEventListener('pointerdown', unmuteAndPlayOnce);
    window.removeEventListener('keydown',    unmuteAndPlayOnce);
  }
  window.addEventListener('pointerdown', unmuteAndPlayOnce, { once:true });
  window.addEventListener('keydown',     unmuteAndPlayOnce, { once:true });
</script>

<canvas id="app" tabindex="0" aria-label="English Night Market"></canvas>

<!-- FirebaseÔºàÂèØÈÅ∏Ôºõ‰∏çÂ°´Â∞±Á∂≠ÊåÅÈõ¢Á∑öÔºâ -->
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>

<script>
(() => {
  // ====== Canvas / Utils ======================================================
  const CANVAS = document.getElementById('app');
  const CTX = CANVAS.getContext('2d');
  const DPR = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
  const TODAY = () => new Date().toISOString().slice(0,10);
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
  const lerp = (a,b,t)=>a+(b-a)*t;

  // rAF ÁØÄÊµÅÁöÑ resize
  let resizeQueued = false;
  function doResize(){
    CANVAS.width  = Math.floor(window.innerWidth  * DPR);
    CANVAS.height = Math.floor(window.innerHeight * DPR);
    CANVAS.style.width  = window.innerWidth  + 'px';
    CANVAS.style.height = window.innerHeight + 'px';
    draw();
    resizeQueued = false;
  }
  function requestResize(){
    if (resizeQueued) return;
    resizeQueued = true;
    requestAnimationFrame(doResize);
  }
  window.addEventListener('resize', requestResize, { passive:true });

  function topInset(){
    const el = document.getElementById('topControls');
    return ((el?.offsetHeight || 0) + 24) * DPR;
  }

  const toastEl = document.getElementById('toast');
  function toast(msg, ms=2800){
    toastEl.textContent = msg;
    toastEl.style.display='block';
    clearTimeout(toastEl._t);
    toastEl._t = setTimeout(()=> toastEl.style.display='none', ms);
  }

  // ====== Theme ===============================================================
  const COL = {
    bgTop:'#0b0f1a', bgBot:'#1a2236', jade:'#1cc2a0', red:'#ff3b30',
    gold:'#ffcf59', ink:'#101422', ink2:'#172036', card:'#11203a',
    line:'rgba(255,255,255,0.15)', white:'#ffffff', faint:'rgba(255,255,255,0.7)', dim:'rgba(255,255,255,0.38)'
  };
  function roundedRect(x,y,w,h,r){
    CTX.beginPath();
    CTX.moveTo(x+r,y);
    CTX.arcTo(x+w,y,x+w,y+h,r);
    CTX.arcTo(x+w,y+h,x,y+h,r);
    CTX.arcTo(x,y+h,x,y,r);
    CTX.arcTo(x,y,x+w,y,r);
    CTX.closePath();
  }
  function drawLantern(x,y,alt=0){
    CTX.save(); CTX.translate(x,y);
    CTX.fillStyle = alt?COL.gold:'#ff934d';
    roundedRect(-16*DPR,-12*DPR,32*DPR,24*DPR,8*DPR);
    CTX.fill();
    CTX.strokeStyle='rgba(255,255,255,0.15)'; CTX.stroke();
    CTX.fillStyle='#ff3b30'; CTX.fillRect(-4*DPR,12*DPR,8*DPR,6*DPR);
    CTX.restore();
  }
  function drawBg(){
    const {width:w,height:h} = CANVAS;
    const g = CTX.createLinearGradient(0,0,0,h);
    g.addColorStop(0,COL.bgTop); g.addColorStop(1,COL.bgBot);
    CTX.fillStyle=g; CTX.fillRect(0,0,w,h);
    const rows=3, cols=9;
    for (let r=0;r<rows;r++){
      const y=(h*0.14)+r*(h*0.14);
      CTX.strokeStyle=COL.line; CTX.lineWidth=2*DPR;
      CTX.beginPath(); CTX.moveTo(w*0.05,y);
      CTX.quadraticCurveTo(w*0.5,y+(r%2?18:-18)*DPR,w*0.95,y);
      CTX.stroke();
      for (let c=0;c<cols;c++){
        const t=c/(cols-1); const x=lerp(w*0.05,w*0.95,t);
        drawLantern(x,y+(r%2?10:-10)*DPR,(r%2?1:0));
      }
    }
  }
  function drawTitle(){
    CTX.save();
    const x = CANVAS.width / 2;
    const y1 = topInset() + 40 * DPR;
    const y2 = topInset() + 70 * DPR;

    CTX.textAlign = 'center';
    CTX.font = `${36*DPR}px ui-sans-serif, system-ui, Segoe UI, Roboto, sans-serif`;
    const text1 = 'Ëã±Ë™ûÂ§úÂ∏Ç ¬∑ English Night Market';
    const text2 = 'Â≠∏Ëã±Êñá ¬∑ Áé©ÈÅäÊà≤ ¬∑ ÊØèÊó•ÈÄ≤Ê≠•';
    const paddingX = 20 * DPR;
    const textWidth = CTX.measureText(text1).width;
    const rectX = x - textWidth / 2 - paddingX;
    const rectY = y1 - 36 * DPR;
    const rectHeight = 50 * DPR;

    CTX.save();
    CTX.shadowColor = 'transparent';
    CTX.fillStyle = 'rgba(0, 0, 0, 0.40)';
    CTX.fillRect(rectX, rectY, textWidth + paddingX * 2, rectHeight);
    CTX.restore();

    // outline
    CTX.save();
    CTX.lineWidth   = 5 * DPR;
    CTX.strokeStyle = 'rgba(0,0,0,0.85)';
    CTX.lineJoin   = 'round';
    CTX.miterLimit = 2;
    CTX.strokeText(text1, x, y1);
    CTX.restore();

    CTX.fillStyle = COL.white;
    CTX.fillText(text1, x, y1);

    // sub
    CTX.font = `${17*DPR}px system-ui`;
    CTX.fillStyle = COL.faint;
    CTX.shadowBlur = 6 * DPR;
    CTX.shadowOffsetY = 1 * DPR;
    CTX.fillText(text2, x, y2);
    CTX.shadowColor = 'transparent';
    CTX.restore();
  }

  // ====== Modes ===============================================================
  const MODES = {
    easy:   { quizTime: 25, snakeTick: 140, label:'‚è±25s / üêçÊÖ¢' },
    normal: { quizTime: 15, snakeTick: 120, label:'‚è±15s / üêç‰∏≠' },
    hard:   { quizTime:  7, snakeTick:  95, label:'‚è±7s / üêçÂø´' }
  };
  let currentMode = localStorage.getItem('nm_mode') || 'normal';
  const modeSel = document.getElementById('modeSel');
  modeSel.value = currentMode;
  document.getElementById('timerHint').textContent = MODES[currentMode].label;

  function setMode(m){
    currentMode = (m in MODES) ? m : 'normal';
    localStorage.setItem('nm_mode', currentMode);
    modeSel.value = currentMode;
    document.getElementById('timerHint').textContent = MODES[currentMode].label;

    if (game){
      const sp = snakeSpeed(currentMode);
      game.speedCfg = sp;
      if (!game.started || game.score === 0){
        game.tickMs = sp.startTick;
      } else {
        game.tickMs = Math.max(sp.minTick, game.tickMs);
      }
    }
    draw();
  }
  modeSel.addEventListener('change', e=> setMode(e.target.value));

  // ====== Audio ===============================================================
  const A = {
    bgm:  document.getElementById('bgm'),
    ok:   document.getElementById('sfxCorrect'),
    bad:  document.getElementById('sfxWrong'),
    tick: document.getElementById('sfxTick')
  };
  if (localStorage.getItem('nm_music') === null) localStorage.setItem('nm_music','1');
  if (localStorage.getItem('nm_sfx')   === null) localStorage.setItem('nm_sfx','1');
  let musicOn = (localStorage.getItem('nm_music') ?? '1') === '1';
  let sfxOn   = (localStorage.getItem('nm_sfx')   ?? '1') === '1';

  A.bgm.volume  = 0.22;
  A.ok.volume   = 0.9;
  A.bad.volume  = 0.9;
  A.tick.volume = 0.7;

  function updateMusicUI(){
    document.getElementById('musicBtn').textContent = musicOn ? 'üîä Music' : 'üîà Music';
    document.getElementById('musicBtn').setAttribute('aria-pressed', musicOn?'true':'false');
  }
  function updateSfxUI(){
    document.getElementById('sfxBtn').textContent   = sfxOn   ? 'üîî SFX'   : 'üîï SFX';
    document.getElementById('sfxBtn').setAttribute('aria-pressed', sfxOn?'true':'false');
  }
  function playSfx(which){
    if (!sfxOn) return;
    const el = which==='ok' ? A.ok : which==='bad'? A.bad : which==='tick'?A.tick : null;
    if (el && el.readyState > 0 && !el.error){
      try { el.currentTime = 0; el.play(); return; } catch {}
    }
    // fallback
    if (which==='ok')   sfxOK();
    if (which==='bad')  sfxBad();
    if (which==='tick') sfxTick();
  }
  document.getElementById('musicBtn').onclick = async ()=>{
    musicOn = !musicOn;
    localStorage.setItem('nm_music', musicOn ? '1':'0');
    updateMusicUI();
    if (musicOn){ try{ await A.bgm.play(); }catch{} } else { A.bgm.pause(); }
  };
  document.getElementById('sfxBtn').onclick = ()=>{
    sfxOn = !sfxOn;
    localStorage.setItem('nm_sfx', sfxOn ? '1':'0');
    updateSfxUI();
  };
  updateMusicUI(); updateSfxUI();

  // WebAudio Fallback
  let AC;
  function ensureAC(){ AC = AC || new (window.AudioContext || window.webkitAudioContext)(); }
  function beep(freq, dur, type='sine', gain=0.15){
    ensureAC();
    const t = AC.currentTime;
    const o = AC.createOscillator();
    const g = AC.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.value = 0;
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(gain, t + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0008, t + dur);
    o.connect(g).connect(AC.destination);
    o.start(t); o.stop(t + dur);
  }
  function sfxOK(){  beep(880, 0.09, 'sine', 0.18); setTimeout(()=>beep(1320, 0.06, 'sine', 0.16), 70); }
  function sfxBad(){ beep(220, 0.11, 'square', 0.16); setTimeout(()=>beep(170, 0.12, 'square', 0.16), 90); }
  function sfxTick(){ beep(1200, 0.045, 'triangle', 0.12); }

  // ====== FirebaseÔºàÂèØÈÅ∏Ôºâ ====================================================
  const FIREBASE_CONFIG = {
    apiKey: "AIzaSyAYiGbTXXRyFzmDBKsWb3dA3e1rJphQl2Q",
    authDomain: "english-night-master.firebaseapp.com",
    projectId: "english-night-master",
    appId: "1:1064693294847:web:14b202c657f14636f08eca",
    storageBucket: "english-night-master.appspot.com",
    messagingSenderId: "1064693294847",
    measurementId: "G-8S28GCQQ78"
  };
  let fb = { app:null, auth:null, db:null, user:null, enabled:false };
  function initFirebase(){
    try{
      if (!FIREBASE_CONFIG || !FIREBASE_CONFIG.apiKey){
        document.getElementById('authStatus').textContent = 'Èõ¢Á∑öÊ®°Âºè';
        document.getElementById('loginBtn').onclick  = ()=> toast('Êú™Ë®≠ÂÆö FirebaseÔºåÁôªÂÖ•ÂÅúÁî®');
        document.getElementById('logoutBtn').style.display='none';
        return;
      }
      fb.app  = firebase.initializeApp(FIREBASE_CONFIG);
      fb.auth = firebase.auth();
      fb.db   = firebase.firestore();
      fb.enabled = true;
      fb.auth.onAuthStateChanged(async(u)=>{
        fb.user = u || null;
        const s = document.getElementById('authStatus');
        const inBtn = document.getElementById('loginBtn');
        const outBtn= document.getElementById('logoutBtn');
        if (fb.user){
          s.textContent = `Â∑≤ÁôªÂÖ•Ôºö${fb.user.displayName || fb.user.email}`;
          inBtn.style.display='none'; outBtn.style.display='';
          if (musicOn) A.bgm.play().catch(()=>{});
          await loadProfileFromCloudMerge();
        }else{
          s.textContent = 'Êú™ÁôªÂÖ•'; inBtn.style.display=''; outBtn.style.display='none';
        }
      });
      document.getElementById('loginBtn').onclick  = async()=>{ try{ await fb.auth.signInWithPopup(new firebase.auth.GoogleAuthProvider()); }catch(e){ toast('ÁôªÂÖ•Â§±Êïó'); } };
      document.getElementById('logoutBtn').onclick = async()=>{ try{ await fb.auth.signOut(); }catch{} };
    }catch(e){ toast('Firebase ÂàùÂßãÂåñÂ§±Êïó'); }
  }

  // ====== Profile =============================================================
  const STORE_KEY = 'nightmarket_english_profile_v1';
  function newProfile(){ return { createdAt:TODAY(), updatedAt:Date.now(), daily:{}, learnedWords:[], xp:0, streak:0, lastDate:'', highScore:0 }; }
  function loadProfileLocal(){ try{ return JSON.parse(localStorage.getItem(STORE_KEY) || 'null') || newProfile(); }catch{ return newProfile(); } }
  let profile = ensureStreak(loadProfileLocal());

  function ensureStreak(p){
    const today = TODAY();
    if (p.lastDate !== today){
      const y = new Date(); y.setDate(y.getDate()-1);
      p.streak = (p.lastDate === y.toISOString().slice(0,10)) ? (p.streak||0)+1 : 1;
      p.lastDate = today;
      if (!p.daily[today]) p.daily[today] = {xp:0, words:0, games:0};
    }
    return p;
  }
  async function loadProfileFromCloudMerge(){
    const local = loadProfileLocal();
    try{
      const ref = fb.db.collection('nightmarket_profiles').doc(fb.user.uid);
      const snap = await ref.get();
      let cloud = snap.exists ? snap.data() : null;
      profile = ensureStreak((cloud && (cloud.updatedAt||0) > (local.updatedAt||0)) ? cloud : local);
      saveProfile();
    }catch{ profile = ensureStreak(local); }
    draw();
  }
  async function saveProfile(){
    profile.learnedWords = Array.from(new Set((profile.learnedWords || []).map(s => String(s).trim())));
    profile.updatedAt = Date.now();
    localStorage.setItem(STORE_KEY, JSON.stringify(profile));
    if (fb.enabled && fb.user){
      try{ await fb.db.collection('nightmarket_profiles').doc(fb.user.uid).set(profile, { merge:true }); }catch{}
    }
  }
  function incToday(key, by=1){
    const t=TODAY();
    profile.daily[t] = profile.daily[t] || {xp:0,words:0,games:0};
    profile.daily[t][key]=(profile.daily[t][key]||0)+by;
  }
  function grantXP(v){ v = Number.isFinite(v)?v:0; profile.xp+=v; incToday('xp', v); }

  // ====== Daily Scores (per date) ============================================
  let dailyScores = JSON.parse(localStorage.getItem('dailyScores') || '{}');
  function saveDailyScores(){ localStorage.setItem('dailyScores', JSON.stringify(dailyScores)); }
  function formatMD(dateStr){
    const d = new Date(dateStr);
    const m = d.getMonth() + 1, day = d.getDate();
    return `${m}/${day}`;
  }
  function getRecentScores(n = 7){
    const out = [];
    const today = new Date();
    for (let i = n - 1; i >= 0; i--){
      const d = new Date(today);
      d.setDate(today.getDate() - i);
      const key = d.toISOString().slice(0,10);
      out.push({ date: key, score: dailyScores[key] });
    }
    return out;
  }

  // ====== Daily Missions ======================================================
  const GOAL_KEY = 'nm_goals_v1';
  function goalsFor(dateStr){
    try{
      const saved = JSON.parse(localStorage.getItem(GOAL_KEY) || '{}');
      if (saved.date === dateStr && saved.goals) return saved.goals;
    }catch{}
    let xp=0, words=0, games=0, n=0;
    const d = new Date(dateStr);
    for(let i=1;i<=3;i++){
      const t = new Date(d); t.setDate(d.getDate()-i);
      const key = t.toISOString().slice(0,10);
      const row = (profile.daily && profile.daily[key]) || null;
      if (row){ xp+=(row.xp||0); words+=(row.words||0); games+=(row.games||0); n++; }
    }
    const axp    = n ? xp/n     : 20;
    const awords = n ? words/n  : 6;
    const agames = n ? games/n  : 1;
    const goals = {
      xp:     clamp(Math.round((axp   *1.2)/10)*10, 20, 200),
      words:  clamp(Math.round(awords*1.2)       ,  5,  20),
      games:  clamp(Math.round(agames*1.2)       ,  1,   5)
    };
    localStorage.setItem(GOAL_KEY, JSON.stringify({ date: dateStr, goals }));
    return goals;
  }

  // ====== Words / Topic / Level ==============================================
  let TOPICS = {};
  let TOPIC_NAMES = [];
  let WORDS = [];
  let wordsReady = false;
  let wordIndex = 0;
  let currentTopic = localStorage.getItem('nm_topic') || '';
  let currentLevel = localStorage.getItem('nm_level') || 'all';

  const topicSel = document.getElementById('topicSel');
  const levelSel = document.getElementById('levelSel');

  const DEFAULT_TOPICS = {
    "Daily Life":[
      {en:"apple",zh:"ËòãÊûú",level:"easy"},{en:"water",zh:"Ê∞¥",level:"easy"},
      {en:"computer",zh:"ÈõªËÖ¶",level:"normal"},{en:"umbrella",zh:"Èõ®ÂÇò",level:"normal"},
      {en:"microscope",zh:"È°ØÂæÆÈè°",level:"hard"}
    ],
    "Travel":[
      {en:"bus",zh:"ÂÖ¨Ëªä",level:"easy"},{en:"ticket",zh:"Á•®",level:"easy"},
      {en:"airport",zh:"Ê©üÂ†¥",level:"normal"},{en:"itinerary",zh:"Ë°åÁ®ãË°®",level:"normal"},
      {en:"immigration",zh:"ÂÖ•Â¢ÉÂØ©Êü•",level:"hard"}
    ],
    "Food & Drinks":[
      {en:"noodles",zh:"È∫µÊ¢ù",level:"easy"},{en:"soup",zh:"ÊπØ",level:"easy"},
      {en:"soy sauce",zh:"ÈÜ¨Ê≤π",level:"normal"},{en:"whiskey",zh:"Â®ÅÂ£´Âøå",level:"normal"},
      {en:"truffle",zh:"ÊùæÈú≤",level:"hard"}
    ]
  };

  function refreshTopicSelect(){
    topicSel.innerHTML = '';
    TOPIC_NAMES.forEach(name=>{
      const o=document.createElement('option'); o.value=name; o.textContent=name; topicSel.appendChild(o);
    });
    if (!TOPIC_NAMES.length){
      const o=document.createElement('option'); o.value=''; o.textContent='No topics'; topicSel.appendChild(o);
    }
    topicSel.value = currentTopic && TOPIC_NAMES.includes(currentTopic) ? currentTopic : (TOPIC_NAMES[0] || '');
  }

  function applyFilters(){
    const pool = (TOPICS[currentTopic] || []);
    WORDS = (currentLevel==='all') ? pool.slice() : pool.filter(w => (w.level||'easy')===currentLevel);
    wordIndex = 0;
    flash = { deck: shuffle([...WORDS]), showBack:false, current:null, lastFlip:0 };
    quiz  = { deck: shuffle([...WORDS]), idx:0, q:null, options:[], correct:0, total:0, feedback:'', deadline:0, lastSecond:null, locked:false };
    if (screen===SCREENS.SNAKE) startGame();
    draw(); saveProfile();
  }

  function setTopic(name){ if (!name) return; currentTopic=name; localStorage.setItem('nm_topic', name); applyFilters(); }
  function setLevel(lv){ currentLevel=lv; localStorage.setItem('nm_level', lv); applyFilters(); }
  topicSel.addEventListener('change', e=> setTopic(e.target.value));
  levelSel.value = currentLevel;
  levelSel.addEventListener('change', e=> setLevel(e.target.value));

  function isLikelyJsonResponse(res){
    const ct = (res.headers.get('content-type')||'').toLowerCase();
    return ct.includes('application/json') || ct.includes('text/json');
  }
  async function loadWords(){
    try{
      const url = './words.json?v='+Date.now();
      const res = await fetch(url, {cache:'no-store'});
      if(!res.ok) throw new Error('HTTP '+res.status);
      if(!isLikelyJsonResponse(res)) throw new Error('Not JSONÔºàË´ãÁ¢∫Ë™ç GitHub Pages Á∂≤ÂùÄÔºâ');
      let data = await res.json();
      if (Array.isArray(data)) data = { "General": data };
      // Ê∏ÖÊ¥ó
      const cleaned = {};
      for (const k of Object.keys(data)){
        const arr = Array.isArray(data[k]) ? data[k] : [];
        const rows = arr.map(w => ({
          en: String(w?.en || '').trim(),
          zh: String(w?.zh || '').trim(),
          level: String(w?.level || 'easy').toLowerCase()
        })).filter(w => w.en && w.zh);
        if (rows.length) cleaned[k] = rows;
      }
      TOPICS = Object.keys(cleaned).length ? cleaned : DEFAULT_TOPICS;
    }catch(err){
      console.warn('Words load failed ‚Üí fallback.', err);
      toast('words.json ËºâÂÖ•Â§±ÊïóÔºåÂÖàÁî®È†êË®≠Â≠óÂ∫´ÔºàË´ãÁ¢∫Ë™çÁî® Pages Á∂≤ÂùÄÔºâ', 4200);
      TOPICS = DEFAULT_TOPICS;
    }
    TOPIC_NAMES = Object.keys(TOPICS);
    if (!currentTopic || !TOPIC_NAMES.includes(currentTopic)) currentTopic = TOPIC_NAMES[0] || '';
    refreshTopicSelect();
    applyFilters();
    wordsReady = true;
  }

  // ====== Flash / Quiz ========================================================
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } return a; }

  function nextWord(){
    if (!WORDS.length) return {en:'loading‚Ä¶', zh:'ËºâÂÖ•‰∏≠‚Ä¶'};
    const w = WORDS[wordIndex % WORDS.length];
    wordIndex++;
    return w;
  }

  let flash = { deck:[], showBack:false, current:null, lastFlip:0 };
  function flipCard(){
    if (!flash.current) return;
    flash.showBack = !flash.showBack;
    if (flash.showBack && flash.current?.en) speakWord(flash.current.en);
    draw();
  }

  function drawFlash(){
    drawBg(); drawTitle(); buttonsClear(); drawTopBar();
    const w=CANVAS.width, h=CANVAS.height;
    if (!flash.current){ flash.deck=shuffle([...WORDS]); flash.current=flash.deck[0]||null; }
    const cw=Math.min(540*DPR,w*0.86), ch=Math.min(340*DPR,h*0.52);
    const cx=w/2 - cw/2, cy=topInset()+190*DPR;
    flash.cardRect = { x: cx, y: cy, w: cw, h: ch };

    CTX.save(); CTX.translate(cx,cy);
    CTX.fillStyle=COL.card; roundedRect(0,0,cw,ch,24*DPR); CTX.fill(); CTX.strokeStyle=COL.line; CTX.lineWidth=2*DPR; CTX.stroke();
    CTX.textAlign='center';
    if (!flash.current){
      CTX.fillStyle=COL.faint; CTX.font=`${20*DPR}px system-ui`; CTX.fillText(wordsReady?'Ê≤íÊúâÂñÆÂ≠ó':'ËºâÂÖ•ÂñÆÂ≠ó‰∏≠‚Ä¶', cw/2, ch/2);
    } else if (!flash.showBack){
      CTX.fillStyle=COL.white; CTX.font=`${34*DPR}px system-ui`; CTX.fillText(flash.current.en, cw/2, ch/2);
      CTX.fillStyle=COL.dim; CTX.font=`${14*DPR}px system-ui`; CTX.fillText('ÈªûÊìäÂç°ÁâáÁøªÈù¢ Flip card', cw/2, ch-20*DPR);
    } else {
      CTX.fillStyle=COL.jade; CTX.font=`${30*DPR}px system-ui`; CTX.fillText(flash.current.zh, cw/2, ch/2 - 8*DPR);
      CTX.fillStyle=COL.faint; CTX.font=`${16*DPR}px system-ui`; CTX.fillText(flash.current.en, cw/2, ch/2 + 24*DPR);
    }
    CTX.restore();

    let bw=Math.min(680*DPR,w*0.92), bh=56*DPR, gap=14*DPR;
    const topY = cy+ch+34*DPR, bottomMargin=28*DPR;
    const avail=h - topY - bottomMargin, need=bh*3 + gap*2;
    if (avail < need){ const s=Math.max(0.72, avail/need); bh*=s; gap*=s; bw*=Math.max(0.85, s); }
    const b1=btnRect(w/2, topY + bh/2, bw, bh);
    const b2=btnRect(w/2, topY + bh/2 + bh + gap, bw, bh);
    const b3=btnRect(w/2, topY + bh/2 + (bh+gap)*2, bw, bh);
    buttons['flashFlip']=b1; buttons['flashKnow']=b2; buttons['flashPractice']=b3;
    drawButton('flashFlip', b1, 'üîÑ ÁøªÈù¢ / Flip');
    drawButton('flashKnow', b2, '‚úÖ ÊàëÊúÉ‰∫Ü / I got it');
    drawButton('flashPractice', b3, 'üß† ÈúÄË¶ÅÂ§öÁ∑¥ / Need practice');

    const back=btnRect(w*0.16, h-60*DPR, 220*DPR, 50*DPR);
    buttons['backMenu']=back; drawButton('backMenu', back, '‚Üê ËøîÂõû Menu');
  }

  function btnRect(cx,cy,w,h){ return {x:cx-w/2,y:cy-h/2,w,h}; }
  function drawButton(id, rect, label, sublabel=null){
    const isHover = hoverId===id; CTX.save(); CTX.translate(rect.x,rect.y);
    const r=16*DPR; CTX.globalAlpha=isHover?1:0.96;
    CTX.fillStyle=isHover?COL.jade:COL.card; roundedRect(0,0,rect.w,rect.h,r); CTX.fill();
    CTX.lineWidth=2*DPR; CTX.strokeStyle=COL.line; CTX.stroke();
    CTX.fillStyle=isHover?COL.ink:COL.white; CTX.textAlign='center';
    CTX.font=`${18*DPR}px system-ui`; CTX.fillText(label, rect.w/2, rect.h/2-(sublabel?6*DPR:0));
    if (sublabel){ CTX.font=`${12*DPR}px system-ui`; CTX.fillStyle=isHover?COL.ink:'rgba(255,255,255,0.75)'; CTX.fillText(sublabel, rect.w/2, rect.h/2+14*DPR); }
    CTX.restore();
  }

  // Quiz
  let quiz  = { deck:[], idx:0, q:null, options:[], correct:0, total:0, feedback:'', deadline:0, lastSecond:null, locked:false };
  function nextQuizWord(){
    if (!quiz || !Array.isArray(quiz.deck) || !quiz.deck.length) return nextWord();
    const i = quiz.idx % quiz.deck.length;
    const w = quiz.deck[i];
    quiz.idx++;
    if (quiz.idx % quiz.deck.length === 0) quiz.deck = shuffle([...quiz.deck]);
    return w;
  }
  function genQuiz(){
    if (!WORDS.length){ quiz.q=null; return; }
    if (!quiz.deck.length) quiz.deck = shuffle([...WORDS]);
    const base = nextQuizWord();
    const wrongs=shuffle([...WORDS].filter(w=>w.en!==base.en)).slice(0,3);
    quiz.q=base; quiz.options=shuffle([base, ...wrongs]);
    const secs=MODES[currentMode].quizTime;
    quiz.deadline=performance.now()+secs*1000;
    quiz.lastSecond=Math.ceil(secs);
    quiz.locked = false;
  }
  function timeLeftMs(){ return Math.max(0, quiz.deadline - performance.now()); }
  function drawQuiz(){
    drawBg(); drawTitle(); buttonsClear(); drawTopBar();
    const w=CANVAS.width, h=CANVAS.height;
    if (!quiz.q) genQuiz();
    const cw=Math.min(540*DPR,w*0.86), ch=140*DPR, cx=w/2-cw/2, cy=topInset()+170*DPR;
    CTX.save(); CTX.translate(cx,cy);
    CTX.fillStyle=COL.card; roundedRect(0,0,cw,ch,20*DPR); CTX.fill(); CTX.strokeStyle=COL.line; CTX.lineWidth=2*DPR; CTX.stroke();
    CTX.fillStyle=COL.white; CTX.font=`${28*DPR}px system-ui`; CTX.textAlign='center';
    CTX.fillText(`Ë´ãÈÅ∏Âá∫„Äå${quiz.q ? quiz.q.en : '‚Ä¶'}„ÄçÁöÑ‰∏≠ÊñáÊÑèÊÄù`, cw/2, ch/2 + 8*DPR);
    CTX.restore();

    const seconds=Math.ceil(timeLeftMs()/1000);
    CTX.fillStyle=seconds<=3?COL.red:COL.white; CTX.font=`${24*DPR}px system-ui`; CTX.textAlign='center';
    CTX.fillText(`‚è± ${seconds}s`, w/2, cy-24*DPR);

    const bw=Math.min(680*DPR,w*0.92), bh=56*DPR, y0=cy+ch+60*DPR;
    quiz.options.forEach((opt,i)=>{
      const r=btnRect(w/2, y0 + i*80*DPR, bw, bh);
      const id='quizOpt'+i; buttons[id]=r; drawButton(id,r,`${i+1}. ${opt.zh}`);
    });

    CTX.fillStyle=COL.faint; CTX.font=`${14*DPR}px system-ui`; CTX.fillText(`ÂæóÂàÜ ${quiz.correct}/${quiz.total}`, w/2, h*0.90);
    const back=btnRect(w*0.16, h-60*DPR, 220*DPR, 50*DPR); buttons['backMenu']=back; drawButton('backMenu', back, '‚Üê ËøîÂõû Menu');
    if (quiz.feedback){
      CTX.fillStyle=quiz.feedback.startsWith('‚úÖ')?COL.jade:COL.red; CTX.font=`${18*DPR}px system-ui`; CTX.fillText(quiz.feedback, w/2, h*0.84);
    }
  }
  function quizChoose(idx){
    if (quiz.locked || !quiz.q) return;
    quiz.total++;
    const pick=quiz.options[idx];
    if (pick && pick.en===quiz.q.en){
      quiz.correct++; quiz.feedback='‚úÖ Ê≠£Á¢∫ÔºÅ+10 XP'; grantXP(10); playSfx('ok');
      if (!profile.learnedWords.includes(pick.en)){ profile.learnedWords.push(pick.en); incToday('words',1); }
    }else{
      quiz.feedback=`‚ùå ÈåØË™§ÔºåÊ≠£Ëß£ÊòØ„Äå${quiz.q.zh}„Äç`; grantXP(1); playSfx('bad');
    }
    quiz.locked = true;
    saveProfile();
    setTimeout(()=>{ quiz.feedback=''; genQuiz(); draw(); }, 700);
  }

  // ====== SnakeÔºàÈòøÂ¨§Ë≤∑ËèúÔºâ===================================================
  function snakeSpeed(mode){
    const base = MODES[mode].snakeTick;
    return {
      baseTick:   base,
      startTick:  Math.round(base * 1.35),
      minTick:    Math.max(60, Math.round(base * 0.55)),
      delta0:     1.8,
      deltaGrow:  0.35
    };
  }
  let game=null;

  function startGame(){
    const size=Math.max(18*DPR, Math.floor(Math.min(CANVAS.width/34, CANVAS.height/30)));
    const cols=Math.floor(CANVAS.width/size)-4;
    const rows=Math.floor((CANVAS.height-topInset())/size)-7;
    const sp = snakeSpeed(currentMode);

    game={
      size, cols, rows,
      ox:Math.floor((CANVAS.width-cols*size)/2),
      oy:Math.floor((CANVAS.height-rows*size)/2)+20*DPR,
      dir:{x:1,y:0}, nextDir:{x:1,y:0},
      snake:[],
      grocery:null,
      tickMs: sp.startTick,
      lastTick:performance.now(),
      alive:true, score:0,
      wordOnPickup:null, started:false, paused:false, bannerT:0,
      speedCfg: sp
    };
    const x0=Math.floor(cols/3), y0=Math.floor(rows/2);
    game.snake=[{x:x0,y:y0},{x:x0-1,y:y0},{x:x0-2,y:y0}];
    game.grocery=spawnGrocery();
    incToday('games',0);
  }

  function drawSnake(){
    drawBg(); drawTitle(); buttonsClear(); drawTopBar();
    if (!game) startGame();

    CTX.save(); CTX.translate(game.ox,game.oy);
    CTX.fillStyle=COL.ink2; roundedRect(0,0,game.cols*game.size,game.rows*game.size,16*DPR); CTX.fill();
    CTX.strokeStyle='rgba(255,255,255,0.06)'; CTX.lineWidth=1*DPR; CTX.beginPath();
    for(let c=1;c<game.cols;c++){ const x=c*game.size; CTX.moveTo(x,0); CTX.lineTo(x,game.rows*game.size); }
    for(let r=1;r<game.rows;r++){ const y=r*game.size; CTX.moveTo(0,y); CTX.lineTo(game.cols*game.size,y); }
    CTX.stroke();

    if (game.grocery) drawGrocery(game.grocery.x, game.grocery.y);
    for(let i=game.snake.length-1;i>=0;i--){
      const seg=game.snake[i];
      if(i===0) drawGrandma(seg.x,seg.y,game.dir);
      else drawCart(seg.x,seg.y,i);
    }
    CTX.restore();

    const w=CANVAS.width;
    // HUDÔºàÊ£ãÁõ§ÂÖßÂè≥‰∏äËßíÔºâ
    {
      const pad = 10*DPR;
      const text = `Score ${game.score}`;
      CTX.font = `${14*DPR}px system-ui`;
      const m = CTX.measureText(text);
      const bx = game.ox + game.cols*game.size - (m.width + pad*2) - 10*DPR;
      const by = game.oy + 10*DPR;
      const bw = m.width + pad*2;
      const bh = 24*DPR;

      CTX.fillStyle = 'rgba(0,0,0,0.35)'; roundedRect(bx, by, bw, bh, 12*DPR); CTX.fill();
      CTX.strokeStyle = '#ff5fa2'; CTX.lineWidth = 2*DPR; CTX.stroke();
      CTX.fillStyle = '#fff'; CTX.textAlign = 'center';
      CTX.fillText(text, bx + bw/2, by + bh/2 + 4*DPR);
    }

    if (!game.started){
      CTX.fillStyle=COL.faint; CTX.font=`${16*DPR}px system-ui`;
      CTX.textAlign='center';
      CTX.fillText('ÊåâÊñπÂêëÈçµÈñãÂßã ¬∑ Use arrow keys to start', w/2, game.oy+game.rows*game.size+26*DPR);
    } else if (game.paused){
      CTX.fillStyle=COL.faint; CTX.font=`${16*DPR}px system-ui`;
      CTX.textAlign='center';
      CTX.fillText('Êö´ÂÅú‰∏≠ ¬∑ Press P to resume', w/2, game.oy+game.rows*game.size+26*DPR);
    } else {
      CTX.fillStyle=COL.dim; CTX.font=`${12*DPR}px system-ui`;
      CTX.textAlign='center';
      CTX.fillText('P Êö´ÂÅú / R Èáç‰æÜ / M Menu', w/2, game.oy+game.rows*game.size+24*DPR);
    }
  }

  function drawGrandma(gx,gy,dir){
    const s=game.size, x=gx*s, y=gy*s; CTX.save(); CTX.translate(x,y);
    CTX.fillStyle='#7c8ba1'; roundedRect(2,2,s-4,s-4,8*DPR); CTX.fill();
    CTX.save(); CTX.translate(s/2,s/2);
    CTX.fillStyle='#ffd9c2'; CTX.beginPath(); CTX.arc(0,0,s*0.28,0,Math.PI*2); CTX.fill();
    CTX.fillStyle='#a7b0bd'; CTX.beginPath(); CTX.arc(0,-s*0.22,s*0.10,0,Math.PI*2); CTX.fill();
    CTX.beginPath(); CTX.arc(0,0,s*0.30,Math.PI*0.7,Math.PI*0.3,true); CTX.strokeStyle='#9aa6b2'; CTX.lineWidth=4*DPR; CTX.stroke();
    CTX.fillStyle='#3a3a3a'; const ex=s*0.10, ey=-s*0.02;
    CTX.beginPath(); CTX.arc(-ex,ey,2.5*DPR,0,Math.PI*2); CTX.fill();
    CTX.beginPath(); CTX.arc(ex,ey,2.5*DPR,0,Math.PI*2); CTX.fill();
    CTX.strokeStyle='#c05b6e'; CTX.lineWidth=2.2*DPR; CTX.beginPath(); CTX.arc(0,s*0.06,s*0.10,0,Math.PI); CTX.stroke();
    CTX.restore();
    CTX.strokeStyle='rgba(255,255,255,0.6)'; CTX.lineWidth=2*DPR; CTX.beginPath();
    const cx=s/2, cy=s*0.82;
    if (dir.x===1){ CTX.moveTo(cx-7,cy); CTX.lineTo(cx+7,cy); CTX.lineTo(cx+1,cy-6); }
    if (dir.x===-1){ CTX.moveTo(cx+7,cy); CTX.lineTo(cx-7,cy); CTX.lineTo(cx-1,cy-6); }
    if (dir.y===1){ CTX.moveTo(cx,cy-10); CTX.lineTo(cx,cy+8); CTX.lineTo(cx-6,cy+2); }
    if (dir.y===-1){ CTX.moveTo(cx,cy+8); CTX.lineTo(cx,cy-10); CTX.lineTo(cx-6,cy-4); }
    CTX.stroke(); CTX.restore();
  }
  function drawCart(gx,gy,i){
    const s=game.size, x=gx*s, y=gy*s; CTX.save(); CTX.translate(x,y);
    CTX.fillStyle=i%2?'#567':'#495871'; roundedRect(4,4,s-8,s-8,6*DPR); CTX.fill();
    CTX.fillStyle='#222'; CTX.beginPath(); CTX.arc(8,s-6,3*DPR,0,2*Math.PI); CTX.fill();
    CTX.beginPath(); CTX.arc(s-8,s-6,3*DPR,0,2*Math.PI); CTX.fill();
    CTX.restore();
  }
  function drawGrocery(gx,gy){
    const s=game.size, x=gx*s, y=gy*s; CTX.save(); CTX.translate(x,y);
    CTX.fillStyle='#d7a96b'; roundedRect(4,6,s-8,s-10,6*DPR); CTX.fill(); CTX.strokeStyle='rgba(0,0,0,0.2)'; CTX.stroke();
    CTX.fillStyle='#5fd16b'; CTX.beginPath(); CTX.arc(s*0.35,8,4*DPR,0,2*Math.PI); CTX.fill();
    CTX.fillStyle='#ff6b6b'; CTX.beginPath(); CTX.arc(s*0.6,9,4*DPR,0,2*Math.PI); CTX.fill();
    CTX.restore();
  }
  function spawnGrocery(){
    let x,y,ok=false;
    while(!ok){
      x=(Math.random()*game.cols)|0; y=(Math.random()*game.rows)|0;
      ok=!game.snake.some(s=>s.x===x&&s.y===y);
    }
    return {x,y};
  }

  function showPickupBanner(word){
    const el = document.getElementById('pickup');
    el.querySelector('.en').textContent = word.en;
    el.querySelector('.zh').textContent = word.zh;
    el.style.opacity = '1';
    el.classList.add('show');
    clearTimeout(el._t);
    el._t = setTimeout(()=>{ el.style.opacity='0'; setTimeout(()=>{ el.classList.remove('show'); }, 200); }, 1100);
  }

  function stepGame(now){
    if (!game || !game.alive || game.paused) return;
    const dt=now - game.lastTick;
    if (dt < game.tickMs) return;
    game.lastTick=now;
    game.dir=game.nextDir;

    const head={...game.snake[0]};
    head.x+=game.dir.x; head.y+=game.dir.y;

    if (head.x<0||head.y<0||head.x>=game.cols||head.y>=game.rows) return gameOver();
    if (game.snake.some(s=>s.x===head.x&&s.y===head.y)) return gameOver();

    game.snake.unshift(head);

    if (head.x===game.grocery.x && head.y===game.grocery.y){
      game.score++;
      profile.highScore=Math.max(profile.highScore||0, game.score);
      if (game.score===1) incToday('games',1);
      grantXP(5);

      const word=nextWord();
      showPickupBanner(word);
      if (!profile.learnedWords.includes(word.en)){
        profile.learnedWords.push(word.en);
        incToday('words',1);
      }
      saveProfile();
      speakWord(word.en);

      game.grocery=spawnGrocery();

      const sp = game.speedCfg || snakeSpeed(currentMode);
      const speedUp = sp.delta0 + sp.deltaGrow * Math.min(game.score, 30);
      game.tickMs = Math.max(sp.minTick, game.tickMs - speedUp);
    }else{
      game.snake.pop();
    }
  }

  function gameOver(){
    const d = TODAY();
    const best = Math.max(dailyScores[d] || 0, game.score);
    dailyScores[d] = best;
    saveDailyScores();

    game.alive=false;
    grantXP(3);
    saveProfile();

    const w=CANVAS.width, h=CANVAS.height;
    CTX.fillStyle='rgba(0,0,0,0.5)'; CTX.fillRect(0,0,w,h);
    CTX.fillStyle=COL.white; CTX.textAlign='center'; CTX.font=`${28*DPR}px system-ui`;
    CTX.fillText('ÈÅäÊà≤ÁµêÊùü ¬∑ Game Over', w/2, h/2-30*DPR);
    CTX.font=`${18*DPR}px system-ui`;
    CTX.fillText(`ÂàÜÊï∏ Score: ${game.score}   ÊúÄÈ´ò High: ${profile.highScore}`, w/2, h/2+6*DPR);
    CTX.fillText('Êåâ R ÈáçÊñ∞ÈñãÂßã ¬∑ Press R to restart', w/2, h/2+36*DPR);
  }

  // ====== UI: ËèúÂñÆ / ÂÑÄË°®Êùø ===================================================
  const SCREENS = { MENU:'menu', DASH:'dash', FLASH:'flash', QUIZ:'quiz', SNAKE:'snake' };
  let screen = SCREENS.MENU, hoverId=null; const buttons={};

  function drawTopBar(){
    const w=CANVAS.width; const yTop = topInset()+86*DPR;
    drawStatPill(w*0.10,yTop,'Streak ÈÄ£Á∫åÂ§©Êï∏', profile.streak, '#ffcf59');
    const day = profile.daily[TODAY()] || {xp:0,words:0,games:0};
    drawStatPill(w*0.30,yTop,'XP ‰ªäÊó•Á∂ìÈ©ó', day.xp||0, '#23d18b');
    drawStatPill(w*0.50,yTop,'Words ÂñÆÂ≠ó', day.words||0, '#38a1ff');
    drawStatPill(w*0.70,yTop,'High Score ÈÅäÊà≤È´òÂàÜ', profile.highScore||0, '#ff5fa2');
  }
  function drawStatPill(x,y,label,value,color){
    CTX.save(); CTX.translate(x,y);
    const pad=10*DPR, text=`${label}: ${value}`;
    CTX.font=`${12*DPR}px system-ui`; const m=CTX.measureText(text); const w=m.width+pad*2, h=24*DPR;
    CTX.fillStyle='rgba(0,0,0,0.35)'; roundedRect(0,0,w,h,12*DPR); CTX.fill();
    CTX.strokeStyle=color; CTX.lineWidth=2*DPR; CTX.stroke();
    CTX.fillStyle=COL.white; CTX.textAlign='center'; CTX.fillText(text,w/2,h/2+4*DPR);
    CTX.restore();
  }
  function drawMenu(){
    drawBg(); drawTitle(); buttonsClear(); drawTopBar();
    const w=CANVAS.width, sectionTop = topInset()+150*DPR;
    const B = [
      {id:'toDash',  y: sectionTop+ 40*DPR, label:'üìä ÈÄ≤Â∫¶ÂÑÄË°®Êùø Dashboard', sub:'ÊØèÊó•ÁõÆÊ®ô ¬∑ ÂñÆÂ≠óÂÆåÊàêÂ∫¶'},
      {id:'toFlash', y: sectionTop+140*DPR, label:'üÉè ÂñÆÂ≠óÈñÉÂç° Flashcards',  sub:'ÁøªËΩâÂç°Áâá ¬∑ Ë™çÁü•Âä†Âº∑'},
      {id:'toQuiz',  y: sectionTop+240*DPR, label:'üìù Ê∏¨È©ó Quizzes',         sub:'ÈÅ∏ÊìáÈ°å ¬∑ Âç≥ÊôÇÂæóÂàÜ'},
      {id:'toSnake', y: sectionTop+340*DPR, label:'üõí ÈòøÂ¨§Ë≤∑ËèúÈÅäÊà≤ (Snake)',   sub:'ÊñπÂêëÈçµÊìçÊéß ¬∑ ÊíøÂà∞Â∞±ÁôºÈü≥'}
    ];
    const rectW = Math.min(w*0.72, 740*DPR), rectH = 68*DPR;
    B.forEach(b=>{
      const rect={x:w/2-rectW/2,y:b.y-rectH/2,w:rectW,h:rectH};
      buttons[b.id]=rect; drawButton(b.id,rect,b.label,b.sub);
    });
    const today = profile.daily[TODAY()] || { xp: 0 };
    const goals = goalsFor(TODAY());
    const pct   = clamp((today.xp || 0) / goals.xp, 0, 1);
    drawProgressRing(w*0.85, sectionTop - 50*DPR, 48*DPR, pct, `‰ªäÊó•XP ${today.xp || 0}/${goals.xp}`);
  }
  function shortenNumber(num) {
    if (num >= 1e9) return (num / 1e9).toFixed(1) + 'B';
    if (num >= 1e6) return (num / 1e6).toFixed(1) + 'M';
    if (num >= 1e3) return (num / 1e3).toFixed(1) + 'K';
    return num;
  }
  function drawDash(){
    drawBg(); drawTitle(); buttonsClear(); drawTopBar();
    const w=CANVAS.width; const startY=topInset()+170*DPR;
    function card(cx,y,ww,hh,title,lines){
      const x=cx-ww/2; CTX.save(); CTX.translate(x,y);
      CTX.fillStyle=COL.card; roundedRect(0,0,ww,hh,18*DPR); CTX.fill();
      CTX.strokeStyle=COL.line; CTX.lineWidth=2*DPR; CTX.stroke();
      CTX.fillStyle=COL.white; CTX.textAlign='left'; CTX.font=`${16*DPR}px system-ui`; CTX.fillText(title,20*DPR,34*DPR);
      CTX.font=`${13*DPR}px system-ui`; CTX.fillStyle=COL.faint;
      lines.forEach((ln,i)=> CTX.fillText(ln,20*DPR,60*DPR+i*20*DPR));
      CTX.restore();
    }
    const today = profile.daily[TODAY()] || {xp:0,words:0,games:0};
    const ww=Math.min(w*0.36,520*DPR), hh=160*DPR;
    const goals = goalsFor(TODAY());
    card(w*0.30,startY,ww,hh,'‰ªäÊó•‰ªªÂãô',[
      `ÂÆåÊàê ${goals.xp} XPÔºö${today.xp>=goals.xp ? '‚úÖ ÂÆåÊàê' : `‚¨ú ${today.xp||0}/${goals.xp}`}`,
      `Â≠∏ ${goals.words} Â≠óÔºö${today.words>=goals.words ? '‚úÖ ÂÆåÊàê' : `‚¨ú ${today.words||0}/${goals.words}`}`,
      `Áé©ÈòøÂ¨§Ë≤∑Ëèú ${goals.games} Â±ÄÔºö${today.games>=goals.games ? '‚úÖ ÂÆåÊàê' : `‚¨ú ${today.games||0}/${goals.games}`}`
    ]);
    card(w*0.70,startY,ww,hh,'Á∏ΩË¶Ω',[
      `Ë®ªÂÜäÊó•ÊúüÔºö${profile.createdAt}`,
      `Á¥ØÁ©ç XPÔºö${shortenNumber(profile.xp)}`,
      `Â∑≤Â≠∏ÂñÆÂ≠óÔºö${profile.learnedWords.length}`
    ]);

    // ÊúÄËøë 7 Â§©
    const recentAll = getRecentScores(7);
    let linesAll = recentAll.map(r => `${formatMD(r.date)}Ôºö${(r.score ?? 0)} ÂàÜ`);
    const yRecent   = startY + hh + 40 * DPR;
    const wwRecent  = Math.min(w * 0.72, 740 * DPR);
    const titleH     = 30 * DPR;
    const lineHeight = 20 * DPR;
    const pad        = 20 * DPR;

    const totalButtons = 4;
    const bottomPad = 18 * DPR;
    const minBtnH = 46 * DPR;
    const minGap  = 12 * DPR;
    const minButtonsBlock = totalButtons * minBtnH + (totalButtons - 1) * minGap + bottomPad;

    const pageAvail = CANVAS.height - yRecent;
    let recentAvail = Math.max(80 * DPR, pageAvail - minButtonsBlock);
    let maxRecentH  = Math.min(300 * DPR, recentAvail);
    let maxLines = Math.floor((maxRecentH - (pad * 2 + titleH)) / lineHeight);
    maxLines = Math.max(1, Math.min(7, maxLines));
    const linesShown = linesAll.slice(-maxLines);
    let hhRecent = pad * 2 + titleH + linesShown.length * lineHeight;
    hhRecent = Math.min(hhRecent, maxRecentH);

    card(w * 0.50, yRecent, wwRecent, hhRecent, 'ÊúÄËøë 7 Â§©', linesShown);

    // ÊåâÈàï
    const rectW  = Math.min(w * 0.7, 740 * DPR);
    let btnH = 60 * DPR,  maxBtnH = 64 * DPR;
    let gap  = 26 * DPR,  maxGap  = 36 * DPR;
    const avail = CANVAS.height - (yRecent + hhRecent) - bottomPad;

    (function fit(){
      let need = totalButtons * btnH + (totalButtons - 1) * gap;
      if (need <= avail) return;
      const extra = need - avail;
      const canShrinkGap = (gap - minGap) * (totalButtons - 1);
      if (canShrinkGap > 0){
        const d = Math.min(extra, canShrinkGap);
        gap = Math.max(minGap, gap - d / (totalButtons - 1));
      }
      need = totalButtons * btnH + (totalButtons - 1) * gap;
      if (need > avail){
        const extra2 = need - avail;
        const canShrinkBtn = (btnH - minBtnH) * totalButtons;
        const d2 = Math.min(extra2, canShrinkBtn);
        btnH = Math.max(minBtnH, btnH - d2 / totalButtons);
      }
      btnH = Math.min(btnH, maxBtnH);
      gap  = Math.min(gap,  maxGap);
    })();

    const used = totalButtons * btnH + (totalButtons - 1) * gap;
    const yStart = yRecent + hhRecent + Math.max(minGap, (avail - used) / 2);

    [
      {id:'backMenu', label:'‚Üê ËøîÂõû Menu'},
      {id:'toFlash',  label:'üÉè ÈñãÂßãÈñÉÂç°'},
      {id:'toQuiz',   label:'üìù ÈñãÂßãÊ∏¨È©ó'},
      {id:'toSnake',  label:'üõí ÈñãÂßãÈòøÂ¨§Ë≤∑Ëèú'}
    ].forEach((b, i) => {
      const centerY = yStart + i * (btnH + gap) + btnH / 2;
      const r = { x: w/2 - rectW/2, y: centerY - btnH/2, w: rectW, h: btnH };
      buttons[b.id] = r;
      drawButton(b.id, r, b.label);
    });
  }

  function drawProgressRing(cx,cy,r,pct,label){
    CTX.save(); CTX.translate(cx,cy);
    CTX.lineWidth=10*DPR; CTX.strokeStyle='rgba(255,255,255,0.15)'; CTX.beginPath(); CTX.arc(0,0,r,0,Math.PI*2); CTX.stroke();
    CTX.strokeStyle=COL.jade; CTX.beginPath(); CTX.arc(0,0,r,-Math.PI/2,-Math.PI/2+pct*2*Math.PI); CTX.stroke();
    CTX.fillStyle=COL.white; CTX.textAlign='center'; CTX.font=`${16*DPR}px system-ui`; CTX.fillText(label,0,6*DPR); CTX.restore();
  }

  // ====== Input / Loop ========================================================
  function buttonsClear(){ for (const k of Object.keys(buttons)) delete buttons[k]; }

  CANVAS.addEventListener('mousemove',(e)=>{
    const rect=CANVAS.getBoundingClientRect();
    const x=(e.clientX-rect.left)*DPR; const y=(e.clientY-rect.top)*DPR;
    hoverId=null;
    for (const [id,r] of Object.entries(buttons)){
      if (x>=r.x&&x<=r.x+r.w&&y>=r.y&&y<=r.y+r.h){ hoverId=id; break; }
    }
    draw();
  }, { passive:true });

  CANVAS.addEventListener('keydown',(e)=>{
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();

    // Quiz Âø´ÈÄüÈçµ 1‚Äì4
    if (screen === SCREENS.QUIZ && ['1','2','3','4'].includes(e.key)) {
      const idx = +e.key - 1;
      if (quiz?.options?.[idx]) quizChoose(idx);
      return;
    }

    if (screen===SCREENS.SNAKE && game){
      if (!game.started && ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) game.started=true;
      if (e.key==='ArrowUp'   && game.dir.y!==1)  game.nextDir={x:0,y:-1};
      if (e.key==='ArrowDown' && game.dir.y!==-1) game.nextDir={x:0,y:1};
      if (e.key==='ArrowLeft' && game.dir.x!==1)  game.nextDir={x:-1,y:0};
      if (e.key==='ArrowRight'&& game.dir.x!==-1) game.nextDir={x:1,y:0};
      if (e.key==='p' || e.key==='P'){ if (game.started){ game.paused=!game.paused; } }
      if (e.key==='r' || e.key==='R'){ startGame(); }
      if (e.key==='m' || e.key==='M'){ screen=SCREENS.MENU; }
    }
    if (e.key==='Escape'){ screen=SCREENS.MENU; }
    if (screen===SCREENS.FLASH && e.key===' '){ flash.showBack=!flash.showBack; draw(); }
  });

  CANVAS.addEventListener('click', (e)=>{
    CANVAS.focus(); // ËÆìÈçµÁõ§Êìç‰ΩúÁ´ãÂç≥ÂèØÁî®
    const rect = CANVAS.getBoundingClientRect();
    const x = (e.clientX - rect.left) * DPR;
    const y = (e.clientY - rect.top)  * DPR;
    if (screen === SCREENS.FLASH && flash.cardRect){
      const r = flash.cardRect;
      if (x >= r.x && x <= r.x + r.w && y >= r.y && y <= r.y + r.h){
        flipCard();
        return;
      }
    }
    if (!hoverId) return;
    handleButton(hoverId);
  });

  function handleButton(id){
    switch(id){
      case 'toDash':  screen=SCREENS.DASH; break;
      case 'toFlash': screen=SCREENS.FLASH; break;
      case 'toQuiz':
        quiz.deck = shuffle([...WORDS]);
        quiz.idx  = 0;
        screen = SCREENS.QUIZ;
        break;
      case 'toSnake': screen=SCREENS.SNAKE; startGame(); break;
      case 'backMenu':
        screen = SCREENS.MENU;
        if (quiz){ quiz.q = null; quiz.locked = false; quiz.total = 0; }
        break;
      default:
        if (id.startsWith('quizOpt')){ const idx=+id.replace('quizOpt',''); quizChoose(idx); return; }
        if (id==='flashFlip')     flash.showBack=!flash.showBack;
        if (id==='flashKnow') {
          grantXP(5);
          if (flash.current && !profile.learnedWords.includes(flash.current.en)){
            profile.learnedWords.push(flash.current.en); incToday('words',1);
          }
          flash.deck.push(flash.deck.shift());
          flash.current=flash.deck[0]||null; flash.showBack=false; saveProfile();
        }
        if (id==='flashPractice'){
          grantXP(3);
          flash.deck.push(flash.deck.shift());
          flash.current=flash.deck[0]||null; flash.showBack=false; saveProfile();
        }
    }
    draw();
  }

  function draw(){
    switch(screen){
      case SCREENS.MENU:  drawMenu(); break;
      case SCREENS.DASH:  drawDash(); break;
      case SCREENS.FLASH: drawFlash(); break;
      case SCREENS.QUIZ:  drawQuiz(); break;
      case SCREENS.SNAKE: drawSnake(); break;
    }
  }

  function tick(now){
    if (screen===SCREENS.SNAKE && game && game.alive && game.started && !game.paused){
      stepGame(now); draw();
    }
    if (screen===SCREENS.QUIZ && quiz.q){
      const secs=Math.ceil(timeLeftMs()/1000);
      if (quiz.lastSecond !== secs){
        quiz.lastSecond=secs;
        if (secs<=3&&secs>0) playSfx('tick');
        draw();
      }
      if (timeLeftMs()<=0 && !quiz.locked){
        quiz.locked = true;
        quiz.total++;
        quiz.feedback = `‚åõ ÊôÇÈñìÂà∞ÔºÅÊ≠£Ëß£ÊòØ„Äå${quiz.q.zh}„Äç`;
        playSfx('bad');
        setTimeout(()=>{ quiz.feedback=''; genQuiz(); draw(); }, 700);
      }
    }
    requestAnimationFrame(tick);
  }

  // ====== Speech ==============================================================
  let preferredVoice = null;
  function pickVoice(){
    try{
      const voices = speechSynthesis.getVoices() || [];
      const prefer=[/Google US English/i,/Samantha/i,/Victoria/i,/Daniel/i,/Karen/i,/Serena/i,/English \(US\)/i];
      for (const rx of prefer){
        const v=voices.find(v=>rx.test(v.name)||rx.test(v.lang));
        if(v){ preferredVoice=v; return; }
      }
      preferredVoice = voices[0] || null;
    }catch{}
  }
  if ('speechSynthesis' in window){
    window.speechSynthesis.onvoiceschanged = pickVoice;
    pickVoice();
  }
  function speakWord(en){
    try{
      const u=new SpeechSynthesisUtterance(en);
      u.lang='en-US'; u.rate=0.92+Math.random()*0.12; u.pitch=0.95+Math.random()*0.13;
      if (preferredVoice) u.voice = preferredVoice;
      window.speechSynthesis.cancel();
      window.speechSynthesis.speak(u);
    }catch{}
  }

  // ====== Boot ================================================================
  function init(){
    doResize();            // ÂàùÂßãÂ∞∫ÂØ∏
    initFirebase();
    loadWords();           // ËÆÄ ./words.jsonÔºàÂ§±Êïó‚ÜíÈ†êË®≠Ôºâ
    setMode(currentMode);  // Ë®≠ÂÆöÊôÇÈñì/ÈÄüÂ∫¶
    draw();
    requestAnimationFrame(tick);
    CANVAS.focus();
  }
  init();
})();
</script>
</body>
</html>
